\chapter{First Order Logic (in construction)}
\label{chap:fol}

\section{Introduction}

This chapter is devoted to the presentation to  data structures for representing first order formulas over a ranked alphabet, and the basic functions and predicates over these types.
Although all the following constructions come directly from~\cite{Goedel}, we introduced minor changes (mainly syntax) to
take into account recent changes in \coq(new constructions, tactics, notations, etc.).


\section{Data types}

\subsection{Languages}

A \emph{language} is a structure composed of relation and function symbols, each symbol is given an \emph{arity} (number of arguments)\,\footnote{As suggested by Russel O'Connor in~\cite{OConnor05}, we consider two arity functions instead of a function defined on the sum type \texttt{Relations + Functions}}.

From~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}
\inputsnippets{fol/LanguageDef} 


\subsubsection{Example: a toy language}
In order to show a few simple examples of statements and proofs, we define a small language with very few symbols:
two constant symbols: $a$ and $b$, three function symbols $f$, $g$ and $h$  (of respective arity 1, 1 and 2), three propositional symbols $A$, $B$ and $C$, a one-place predicate symbol $P$, and a binary relational symbol $R$. 
 
From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}.

\inputsnippets{FolExamples/ToyDef}

\begin{remark}
  \label{rem:underscores}
  The constructors of types \texttt{Rel} and \texttt{Fun} are suffixed by an underscore, in order to reserve the names \texttt{a}, \texttt{f}, \texttt{h}, \texttt{R}, etc. to functions which build terms and formulas (please look at Sect~\ref{sec:fol-term-notations} and \ref{sec:fol-atomic-notations}).
\end{remark}


\subsection{Terms}

Given a language $L$, we define the type of \emph{terms} and
$n$-\emph{tuples of terms} over $L$.

\inputsnippets{fol/TermDef} 



\begin{remark}[Variables]
In O'Connor's formalization of first-order logic,  variables are \gallina terms of the form (\texttt{var $L$ $i$}), where $L$ is
 a language and $i$ a natural number. 
Although other choices may be considered : PHOAS, de Bruijn indices, etc,  we   respect this representation, in order not to break long proof scripts which use this representation (please look at \cite{OConnor05} for a related discussion).
  
\end{remark}

\begin{remark}
This representation of terms uses mutually inductive data-types instead of list of terms. Please see also Remark~\ref{hydra:mutually-inductive-vs-lists}.
\end{remark}

\subsubsection{Examples}
\label{sect:folTermExamples}

Let us define some \gallina terms over our toy language, respecively corresponding to the terms $a$,
$f(a)$, and $h(f(a),a)$. The fourth ``term'' is not well formed, since the arity of $h$ is not respected\,\footnote{Strictly speaking, it's not a (well typed) term!}.

\inputsnippets{FolExamples/TermExamples1} 



\subsection{Formulas}



The type of first order formulas over $L$ is defined 
in~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} as an inductive data type.

\inputsnippets{fol/FormulaDef}

The  abstract syntax of first-order formulas is completed 
with a few abbreviations\,\footnote{Technically, these abbreviations take the form of \emph{global definitions}}. Note that we are studying \emph{classical} first-order logic, for instance the existential quantifier is derived from the universal one through negation. 

\inputsnippets{fol/FolFull, fol/folPlus}

\subsection{Examples}
\label{sect:folFormExamples}



Let us give a few examples of first-order formulas over $L$.

\label{fol:examplesf1f2f3}
\begin{enumerate}
\item $R\;a\;b$
\item $\forall v_0\; v_1, R\;v_0\;v_1 \leftrightarrow R\;v_1\;v_0$
\item $ \forall v_0, v_0=a \vee \exists\;v_1,\, v_0= f(v_1)$
\end{enumerate}


\inputsnippets{FolExamples/FormExamples}


\section{Simplified notations for terms and formulas}
\label{sect:fol-notations}



 We use \coq's \texttt{Notation} features to print and parse terms and formulas  in a more readable form.

 \subsection{Parsing and printing terms}
 \label{sec:fol-term-notations}

Let us consider the term $t_2$ of Sect\ref{sect:folTermExamples}~. Its normal form is quite hard to read:

\inputsnippets{FolExamples/beforeAbbreviations}

We may use \coq's abbreviation feature  to print and parse $L$-terms with a more natural concrete syntax.

\inputsnippets{FolExamples/termAbbreviations, FolExamples/NowItsBetter}





\subsection{Parsing and printing first-order formulas}

In order to make the first order formulas more readable, we define  a  notation scope called \texttt{fol\_scope}, which contains 
notations for connectives and quantifiers. The \texttt{\%fol} delimiter 
allows the user to distinguish \texttt{FOL} connectives from their \coq equivalent.


\vspace{6pt}

\noindent From \href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}

\inputsnippets{fol/folScope1}

The following notations are used (when printing) when  some computation 
    expands a disjunction, conjuction, etc. 
    in terms of implication and negation.

\inputsnippets{fol/folScope2}

\subsubsection{Simplified notations for atomic formulas}
\label{sec:fol-atomic-notations}

In addition to \texttt{fol\_scope}, we can introduce a few abbreviations specific to our toy language.

\inputsnippets{FolExamples/toyNotationForm}

The following interactions show how the formulas 
of~\ref{sect:folFormExamples} may be 
parsed or printed. 

\noindent From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}

\vspace{6pt}

\inputsnippets{FolExamples/toyNotationForm2}




\section{Computing and reasoning on first-order formulas}

\subsection{Bound variables}

  In~\cite{Goedel}, there is no De Bruijn encoding of bound variables (see also~\cite{OConnor05}). The following example shows two formulas which share the same structure, are logically equivalent, but are not Leibniz equal.



\vspace{4pt}

\noindent From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}
  
\inputsnippets{FolExamples/boundVars}  

  \begin{todo}
   Link to the lemmas which attest the equivalence of these formulas (properties of substitution, logical equivalence).
  \end{todo}




\subsection{Decidability of equality}

Under the assumption that equality is decidable on 
function and relation symbols of any language $L$,
we get decidability of equality on terms and formulas.
Because of dependent types, the proofs are quite long and technical. The reader may consult them in \href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}

\begin{todo}
  Should we talk about the decomposition lemmas
\texttt{nilTerms} and \texttt{consTerms} ?
\end{todo}

\inputsnippets{fol/formDec1, fol/formDec2,
fol/formDec3,fol/formDec4,fol/formDec5}

\subsection{Induction principles on formula depth}

The purpose of this section is to present ways of proving 
properties of any formula $a$ (or defining functions over the type of formulas).

Structural induction/recursion principles are generated by 
\texttt{Formula}'s definition, for instance:

\inputsnippets{FolExamples/FormulaRect}







\subsubsection{Depth of a formula}
As explained in~\cite{OConnor05}, some functions on the \texttt{Formula} type cannot be defined by structural recursion in 
O'Connors formalization. For instance, the substitution of a term to a free variable (because of quantifiers). 
In such cases, we may define functions by well-founded recursion. In this section, we consider the well-founded strict-order associated with a measure: the \emph{depth} of a formula.

\begin{todo}
Forward link to its application.
\end{todo}


The function \texttt{depth} computes the \emph{depth} of the 
 skeleton of any formula.

\inputsnippets{fol/depthDef,  FolExamples/DepthCompute}

\subsubsection{Induction on depth}

The function \texttt{depth} allows us to define a strict order on 
\texttt{Formula $L$}.


\inputsnippets{FolExamples/ltDepth1}

\begin{todo}
Motivate the induction principles based on depth. Compatible with term substitution and universal quantifier elimination.
\end{todo}



\inputsnippets{FolExamples/depthRecDemo}

\begin{todo}
 Look for the principles which are really used in Ackermann or/and Goedel libraries, and comment them.
 Maybe skip the helpers (unused in other files)
\end{todo}

The library~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} contains several induction principles, applied 
throughout \texttt{Ackermann} and \texttt{Goedel} projects.


Let us for instance have a look  at \texttt{Formula\_depth\_ind2}. Its application in order to prove $P\;a$ generates 5 sub-goals. 

\inputsnippets{FolExamples/depthRecDemo2}

\begin{itemize}
\item Goals $1$ to $4$ correspond to  usual proofs by structural induction.
\item Goal $5$ is associated with a universal quantification $f=\forall\,v,a$. In this case, we have to prove that $P\;b$ holds for any formula $b$ which has a depth strictly less than $f$. Such a $b$ may for instance the result of replacing the free occurrences of $v$ in $a$ with any term $t$.
  \begin{todo}
   Make a link to an appropriate example.
  \end{todo}
\end{itemize}



\subsection{Free variables and substitutions}

Section \texttt{Free\_Variables} 
of~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} defines the list of free variables which occur in a term (respectively in a formula).

We advise the reader to look at these functions, and limit ourselves to give a few examples.

Let us consider again the formulas \texttt{f3} and \texttt{f4} of page~\pageref{fol:examplesf1f2f3}.

The list of free variable occurrences of a formula is given by the function \texttt{freeVarFormula}. The function \texttt{close}
binds all the free variables of a formula with universal quantifiers.

\inputsnippets{FolExamples/freeVarExamples}


\section{Languages for Arithmetic}



Two languages built with the usual symbols of arithmetic are 
defined in ~\href{../theories/html/hydras.Ackermann.Languages.html}{Ackermann.Languages}.

\begin{itemize}
\item The first language: \texttt{LNT} (\emph{Language of Number Theory}) has just function symbols for $+$, $\times$, $0$ and successor.
\item The second language: LNN (\emph{Language of Natural Numbers})  has
the same function symbols as LNT plus one relation symbol for the strict inequality $<$ : \texttt{LT} (less than).
\end{itemize}

\subsubsection{Language of Number Theory (LNT)}

First, we declare two alphabets.

\inputsnippets{Languages/LNTDef1} 

In a second time, we build \texttt{LNT} and \texttt{LNN} by filling \texttt{Language}'s \texttt{arity} field.

\inputsnippets{Languages/LNTDef2} 

\begin{remark}
  We depart a little from \cite{Goedel}'s notations, where the 
function and relation symbols are called \texttt{Plus}, 
\texttt{Mult}, \texttt{LT}, etc. In our version, these type constructors are called \texttt{Plus\_}, 
\texttt{Mult\_}, \texttt{LT\_}, etc., while the names without final underscores are bound to term building functions (\emph{e.g.}
the function which takes two terms and builds the term representing their sum) (see Remark~\ref{rem:underscores}).
\end{remark}


\subsubsection{Language of Natural Numbers (LNN)}

\texttt{LNN} is an extension of \texttt{LNT}, by the addition 
of the $<$ relation symbol.


\inputsnippets{Languages/LNNDef}



\subsubsection{Examples}

Let us show a few examples (from ~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}).

\inputsnippets{FolExamples/arityTest} 
 



% \subsubsection{Examples}

% With our toy language, we can build the following terms, respectively written $a$, $f(a)$ and $f(f(v_1))$ in usual mathematical notation. 

% Writing these terms in bare \gallina syntax would result in quite clumsy scripts. Thus, we may use a still experimental notation scope which allows us to write/print terms and formulas in a 
% notation similar to \coq's.





% We put both the associated \coq{} terms, in bare \gallina{} syntax, and with a still experimental and provisional notation, defined in
% ~\href{../theories/html/hydras.Ackerm.FOL_notations.html}{MoreAck.FOL\_notations}).



% \inputsnippets{FolExamples/toyNotation}

% \inputsnippets{FolExamples/smallTerms}


For instance the term $v_1+0$, where $v_1$ is a variable,
is represented by the following \gallina term of type 
(\texttt{fol.Term LNT}).

\inputsnippets{FolExamples/v1Plus0} 






\inputsnippets{LNN/instantiations}

\section{Notations for Formulas (experimental)}

In order to get more readable terms and formulas, we can define a few notations in ~\href{../theories/html/hydras.MoreAck.FOL_notations.html}{MoreAck.FOL\_notations} and
~\href{../theories/html/hydras.MoreAck.LNN.html}{MoreAck.LNN}.
Please note that these notation scopes are experimental: We are going to use them in examples and exercises before using them in large original proof scripts (in the \texttt{ordinals/Ackermann/} sub-directory).

We try to define notation scopes as close as possible to \coq's syntax for propositions.

Let us take for instance the following proposition (in math form):

$$\forall\, v_0,\, v_0=0\vee \exists\,v_1,\,v_1=1+v_0$$

Here is a definition, using directly the \texttt{goedel/Ackermann}'s project syntax.

\inputsnippets{LNN_Examples/uglyF0}

Note that, because of redefinitions, the disjonction \texttt{orH}
can be expanded in terms of  implication and negation (for instance when we use \texttt{Compute}).

\begin{todo}
  Present the general issue about evaluation, and our provisional solution.
\end{todo}

\inputsnippets{LNN_Examples/uglyF0a}



\inputsnippets{LNN_Examples/CNNF0}




\section{Proofs}

\subsection{Contexts as lists}
\begin{todo}
Describe the \texttt{Prf} type (from \texttt{folProof.v}).

Give examples in a toy language.

Give an example which motivates \texttt{SysPrf}:

$P,P , P\arrow P \arrow Q, \vdash Q$ ?
\end{todo}

\begin{exercise}

Prove the following lemma:
\inputsnippets{FolExamples/eqRefl}

\end{exercise}

\subsection{Contexts as sets}

\begin{exercise}

Prove the following lemma:
\inputsnippets{FolExamples/MPdiag}

\end{exercise}


\section{Derived rules and natural deduction}


 The library 
 \href{../theories/html/hydras.Ackermann.folLogic.html}{Ackermann.folLogic} contains many derived rules which allow the user to build proofs in a natural deduction style (with introduction and elimination rules).

\subsection{Example}

For instance, let us prove Peirce's rule.
 (in  ~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples} ).

\subsubsection{Prelude}

%\inputsnippets{folPeirce/prelude}


\subsection{Proof of Peirce's law}


\inputsnippets{FolExamples/PeirceProof}

Let us try to do an implication introduction.

\inputsnippets{FolExamples/step1}

Now, we may use the law of excluded middle with the formula $P$. The only non-trivial case is about $\sim P$.

\inputsnippets{FolExamples/step2}

The rest of the proof is composed of basic proof steps, 
and bookkeeping steps (about \texttt{Ensembles.In}).

\inputsnippets{FolExamples/step3, FolExamples/step4}

\index{ackermann}{Exercises}
\begin{exercise}
Prove, using the rules described in 
 \href{../theories/html/hydras.Ackermann.folLogic.html}{Ackermann.folLogic}, the famous \emph{drinkers theorem}:

$$\exists\,x,\; (D(x)\Longrightarrow \forall\,y,\; D(y))$$
\end{exercise}

where $D$ (for ``drinks'') is some predicate symbol of arity $1$.


