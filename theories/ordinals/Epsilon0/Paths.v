(** *

   Transition systems associated with canonical sequences
 *)

(**  P. Casteran, University of Bordeaux and Labri


       After J. Ketonen and R. Solovay's paper
  " Rapidly Growing Ramsey Functions" _in_
    Annals of mathematics, Mar. 1981 

 *)



Require Import Canon  MoreLists First_toggle OrdNotations.
Import Relations Relation_Operators.
From Coq Require Import Lia.

Set Implicit Arguments.
Open Scope t1_scope.


(** ** relations  associated with canonical sequences *)

Definition transition_S i : relation T1 :=
  fun alpha beta =>  alpha <> zero /\ beta = canon alpha (S i).

Definition transition i : relation T1 :=
  match i with 0 => fun _ _ => False | S j => transition_S j end.
                             

Definition bounded_transition (n:nat) alpha beta :=
  exists i:nat, (i <= n)%nat /\ transition_S i alpha beta. 

(** ** Paths inside epsilon_0 

  In this module, we study paths; i.e. sequences generated by the relations 
associated with   the [canonS i] functions. In module [O2H] we show how pathes are 
 related to hydra battles. Thus, the various classes of battles are described by predicates on pathes.
*)


(** path_toS beta s alpha :
    pathS alpha s beta :

   beta is reachable from alpha through the sequences s of indices
   ( zeros are ignored) 

   Note that only beta can be equal to zero
 *)


Inductive path_to (beta: T1) : list nat -> T1 -> Prop :=
  path_to_1 : forall (i:nat) alpha , 
    i <> 0 ->
    transition i alpha beta ->
    path_to beta (i::nil) alpha
| path_to_cons : forall i alpha s gamma,
    i <> 0 ->
    transition i alpha gamma ->
    path_to beta  s gamma ->
    path_to beta  (i::s) alpha.

Definition path alpha s beta := path_to beta s alpha.

(** tries to solve a goal of the form (path_to beta s alpha) *)


Ltac path_tac := (* ugly ! *)
  repeat (match goal with
          | [ |- path_to ?b (?x :: ?y :: ?s) ?a ] =>
            (eright; [discriminate
                    | split;[discriminate | reflexivity]
                    | cbn])
          |  [ |- path_to ?b (?x :: nil) ?a ] =>
                   (eleft; [discriminate |
                            split;cbn ; [discriminate | reflexivity]])
                         
                 end).

Example ex_path1: path_to T1.omega (2::2::2::nil) (T1.omega * 2).
Proof. path_tac. Qed.

Example ex_path2: path_to T1.omega (3::4::5::6::nil) (T1.omega * 2).
Proof. path_tac. Qed.

Example ex_path3: path_to zero (interval 3 14) (T1.omega * 2).
Proof. cbn;path_tac. Qed.

Example ex_path4:  path_to zero (repeat 3 8) (T1.omega * 2).
Proof. cbn; path_tac. Qed.


(** path_toS beta s alpha :
    pathS alpha s beta :

   beta is reachable from alpha through the sequence of indices
   (shift s)

   Note that only beta can be equal to zero
 *)

Lemma path_to_not_nil  alpha s beta : path_to beta s alpha -> s <> nil.
induction 1; discriminate.
Qed.

Inductive path_toS (beta: T1) : list nat -> T1 -> Prop :=
|  path_toS_1 : forall (i:nat) alpha, transition_S i alpha beta ->
                                      path_toS beta (i::nil) alpha
| path_toS_cons : forall i alpha s gamma,
    transition_S i alpha gamma ->
    path_toS beta  s gamma ->
    path_toS beta  (i::s) alpha.


Definition pathS alpha s beta := path_toS beta s alpha.



(** ** Accessibility (without traces) *)


Definition acc_from alpha beta := exists s, path_to beta s alpha. 


(** **  following a path *)

(**  useful helper ? *)
Fixpoint gnawS (alpha : T1) (s: list nat) :=
  match  s with
    | nil => alpha
    | (i::s') => gnawS (canon alpha (S i)) s'
  end.

Fixpoint gnaw (alpha : T1) (s: list nat) :=
  match  s with
    | nil => alpha
    | (0::s') => gnaw  alpha s'
    | (S i :: s')  =>  gnaw (canon alpha (S i)) s'
  end.



Fixpoint standard_gnaw (i:nat)(alpha : T1)(l:nat):  T1  :=
  match l with
  | 0 => alpha
  | S m => standard_gnaw (S i) (canon alpha i) m
  end.

(** alpha ---> beta in KP 
             n
 *)


Definition KP_arrow n := clos_trans_1n T1 (bounded_transition n).


(** ** Paths with constant index *)

Definition const_pathS i :=
  clos_trans_1n T1 (fun alpha beta => alpha <> zero /\
                                      beta = canon alpha (S i)).

Definition const_path i alpha beta :=
  match i with
    0 => False
  | S j => const_pathS j alpha beta
  end.

Definition const_pathS_eps i := clos_refl _ (const_pathS i).

(** ** standard paths *)


(**  standard path from (i, alpha) to (j, beta) *)

(* todo : use transition_S in the definition *)

Inductive standard_pathRS (j:nat)( beta : T1):  nat -> T1 -> Prop :=
  stdS_1 : forall i alpha, alpha <> zero ->
                           beta = canon alpha (S i) -> j = i ->
                          standard_pathRS j beta i  alpha
| stdS_S : forall i alpha, standard_pathRS j beta (S i) (canon alpha (S i))  ->
                          standard_pathRS j beta i alpha.

Definition standard_pathS  i alpha j beta := standard_pathRS j beta i alpha.

Inductive standard_pathR (j:nat)( beta : T1):  nat -> T1 -> Prop :=
  std_1 : forall i alpha, alpha <> zero ->
                          beta = canon alpha i -> j = i -> i <> 0 ->
                          standard_pathR j beta i  alpha
| std_S : forall i alpha, standard_pathR j beta (S i) (canon alpha i)  ->
                          standard_pathR j beta i alpha.


Definition standard_path  i alpha j beta := standard_pathR j beta i alpha.

Lemma path_to_interval_inv_le alpha beta i j :
  path_to beta (interval i j) alpha ->
  (i <= j)%nat.
Proof.
  destruct (le_lt_dec i j).
  auto.
  rewrite empty_interval.
   intro H; apply path_to_not_nil in H; now destruct H.
   auto.
Qed.

(** ** Bridge Lemmas *)

Lemma gnawS_gnaw s alpha :
  gnawS alpha s = gnaw alpha (shift s).
Proof. revert alpha;  induction s; cbn; auto. Qed.  


Lemma gnaw_gnawS s alpha :
  gnaw alpha s = gnawS alpha (unshift s).
Proof.
  revert alpha; induction s; cbn; auto.
  destruct  a as [|i]; auto.
  intros; rewrite IHs; auto.  
Qed.

Lemma path_toS_path_to  alpha s beta :
  path_toS beta s alpha <->
  path_to beta (shift s) alpha.
Proof.
  split.
  - induction 1.
    + left; auto.
    + right with gamma; auto.
  - revert alpha beta; induction s.
    + inversion 1.
    + simpl; inversion 1.
      * assert (s = nil). {       
        destruct s; trivial. discriminate.
         }
      subst s;  simpl in H;  inversion H.
      left;  auto.
      inversion H10.
     * right with gamma; auto.
Qed.

Lemma path_to_path_toS  :
  forall alpha s beta,   path_to beta s alpha ->
                        path_toS beta (unshift s) alpha.
Proof.
  induction 1.
   -  destruct i as [| j]; [absurd (0 = 0); auto |].
      left; auto.
   - destruct i as [| j]; [absurd (0 = 0); auto |].
     right with gamma; auto.
Qed.

Lemma path_to_path_toS_iff  :
  forall alpha s beta,  ~ In 0 s -> path_to beta s alpha <->
                        path_toS beta (unshift s) alpha.
Proof.
  split.
  -  apply path_to_path_toS.
  - rewrite <- (unshift_shift s); auto.
     repeat rewrite shift_unshift.
     apply path_toS_path_to.
 Qed.


Lemma path_toS_nf beta s alpha: path_toS beta s alpha -> nf alpha -> nf beta.
Proof.
  induction 1.  
  - destruct H; subst; intro; now apply nf_canon.    
  - intro; apply IHpath_toS; auto.
    destruct H; subst; now apply nf_canon.   
Qed.

Lemma path_acc_from alpha s beta:
    path alpha s beta -> acc_from alpha beta.
Proof.
  now exists s. 
Qed.

Lemma path_toS_gnawS : forall s alpha beta,   path_toS beta s alpha ->
                                              beta = gnawS alpha s.
Proof.
  induction 1; trivial.
  - simpl; now destruct H.
  - simpl; destruct H; now subst. 
Qed.

(** ** Composition/decomposition of paths *)

Lemma path_toS_app beta t gamma :
    path_toS gamma t beta -> forall alpha s, path_toS beta s alpha ->
                                             path_toS gamma (s++t)%list alpha.
Proof.
  induction 2.
  - cbn; right with beta; auto.
  - cbn; right with gamma0; auto.
Qed.

Lemma path_to_app beta t gamma :
    path_to gamma t beta -> forall alpha s, path_to beta s alpha ->
                                             path_to gamma (s++t)%list alpha.
Proof.
  induction 2.
  - cbn; right with beta; auto.
  - cbn; right with gamma0; auto.
Qed.


Lemma path_toS_decompose gamma s alpha :
  forall beta t u,  s = t++u ->
                    path_toS beta t alpha -> path_toS gamma u beta ->
                    path_toS gamma s alpha.
Proof.
  intros.
   rewrite H; eapply path_toS_app; eauto.
Qed.

Lemma path_to_decompose gamma  alpha beta s t u  :
  s = t++ u ->
  path_to beta t alpha -> path_to gamma u beta ->
  path_to gamma s alpha.
Proof.
  intros.  
   rewrite H; eapply path_to_app; eauto.
Qed.

Ltac path_decompose x :=
  match goal with |- path_to ?a (interval ?from ?to) ?b =>
                  rewrite (interval_app from x to);
                  [eapply path_to_app | try lia | try lia]
  end.

Lemma path_toS_appR     : forall u  gamma  alpha,
    path_toS gamma u alpha ->
    forall s t, s <> nil -> t <> nil -> u = s ++ t ->
                exists beta, 
                  path_toS beta s alpha /\ path_toS gamma t beta.
Proof.
  induction 1.
  - intros.
    elimtype False. {
      destruct s, t; auto.
      simpl in H2.      
      injection H2.
      intros.
      destruct s; try discriminate.
    }
  -  intros;  destruct s.
     + destruct s0.
       * now destruct H1.
       * clear H1; simpl in H3; injection H3; intros; subst.
         symmetry in H1;apply app_eq_nil in H1.
       destruct H1; contradiction. 
     + destruct s0.
      * now destruct H1.
       * simpl in H3; injection H3; intros. subst.
         destruct s0.
       --    simpl in *; exists gamma0; split.
        ++  left;  auto.
        ++ subst t; auto.
       --  destruct (IHpath_toS (n1::s0) t); auto.
        ++  discriminate.
        ++   exists x; split; auto.
           ** now right with gamma0.
           **  destruct H5;auto.
Qed.

Lemma path_to_appR     : forall u  gamma  alpha,
    path_to gamma u alpha ->
    forall s t, s <> nil -> t <> nil -> u = s ++ t -> ~ In 0 u ->
                exists beta, 
                  path_to beta s alpha /\ path_to gamma t beta.
  intros u gamma alpha H s t H0 H1 H2 H3;
    rewrite path_to_path_toS_iff in H; [| trivial].
  - destruct
      (@path_toS_appR  (unshift u) gamma alpha H (unshift s) (unshift t)).
   + apply unshift_not_nil; auto.
    * intro; apply H3; subst.
      apply in_or_app; auto.
   + apply unshift_not_nil;  intro; apply H3; subst.
     apply in_or_app; auto.
     now destruct H1.
   +  subst; now rewrite  unshift_app. 
   +  exists x;destruct H4; split.
      * rewrite path_to_path_toS_iff; auto.
        intro; apply H3; subst; apply in_or_app; auto.
      * rewrite path_to_path_toS_iff; auto.
        intro; apply H3; subst; apply in_or_app; auto.   
Qed.

Lemma path_toS_zero_but_last : forall x u alpha,
    path_toS zero (x::u)  alpha -> u <> nil ->
    path_toS one (but_last x u) alpha.
Proof.
  destruct u.
  - simpl; inversion 1.
   +  now destruct 1.    
   +  now destruct 1. 
  - intros alpha H H0;  rewrite <- but_last_app in H.
    specialize (path_toS_appR H).
    intro H1;
      specialize (H1 (but_last x (n::u))
                     (simple_last  x  (n::u)::nil)).
    simpl in H1; destruct H1; try discriminate; auto.
    destruct H1.
    inversion H2.
    + destruct H4.
      symmetry in H6; destruct (canonS_zero_inv _ _ H6).
     * contradiction.
     *  subst x0; simpl.
        subst alpha0; auto.
    + inversion H7.
Qed.

Lemma path_toS_zero_one : forall x  alpha,
    path_toS zero (x::nil)  alpha -> alpha = one.
Proof.
  inversion 1.
  - subst; destruct H1.
    symmetry in H1; destruct (canonS_zero_inv _ _ H1).
    + contradiction.
    +  auto.
  -  inversion H4.
Qed.

Lemma path_toS_zero_inv x u alpha :
  path_toS zero (x::u) alpha -> {alpha = one /\ u = nil} +
                                {u <> nil /\ path_toS one
                                                      (but_last x u)
                                                      alpha}.
Proof.
  destruct u.
  - left;split; auto;  eapply path_toS_zero_one; eauto.
  -  right; split.
    +  discriminate.
    +  apply  path_toS_zero_but_last; auto.
       discriminate.
Qed.


Lemma path_toS_zero alpha s : ~ path_toS alpha s zero.  
Proof.
  red; inversion 1.
  destruct H0; now apply H0.
  destruct H0; now apply H0.
Qed.

Lemma path_to_zero alpha s: ~ path_to alpha s zero.
Proof.
  intro H; apply path_to_path_toS in H.
  eapply path_toS_zero; eauto.  
Qed.

(** todo : use this lemma to remove useless hypotheses *)

Lemma path_to_not_In_zero : forall alpha s beta,
    path_to beta s alpha -> ~ In 0 s.
Proof.
  induction 1.
  - red; destruct 1.
     +  contradiction.
     +   destruct H1.  
  -   intro H2;  destruct H2;  contradiction. 
Qed.


Lemma path_toS_tail  alpha s beta :
    path_toS beta s alpha -> 
    forall gamma n, nf (ocons gamma n alpha) ->
                    path_toS (ocons gamma n beta) s (ocons gamma n alpha).
Proof.
  induction 1.
  - subst; left; split.
    + discriminate.
    + unfold canonS;rewrite canon_tail; auto.
     *  destruct H; now subst.
     *  now destruct H.
  - intros; subst;  right with (ocons gamma0 n (canon alpha (S i))).
    + split.
      * discriminate.
      * rewrite canon_tail; auto.
        now destruct H.
    + destruct H; subst; apply IHpath_toS; auto.
      eapply nf_LT_right; eauto.
      apply canonS_LT; trivial.
      eapply nf_inv2, H1. 
Qed.


Lemma path_to_tail  alpha s beta :
  path_to beta s alpha -> 
  forall gamma n, nf (ocons gamma n alpha) ->
                  path_to (ocons gamma n beta) s (ocons gamma n alpha).
Proof.
  intros H  gamma n Hnf; assert (H1:= path_to_not_In_zero H).
  rewrite path_to_path_toS_iff; auto.
  apply path_toS_tail; auto.
  now rewrite <- path_to_path_toS_iff.
Qed.


Lemma path_toS_mult  alpha s  i : nf alpha -> 
    path_toS zero s (phi0 alpha) -> 
    path_toS (ocons alpha i zero) s (ocons alpha (S i) zero).
Proof.
  inversion 2.
  - subst;   inversion H1.
     assert (alpha = zero).
     { destruct H1; symmetry in H3.
       apply canonS_zero_inv in H3; destruct H3.
       - discriminate.
       - now injection H3.
     }
     subst; left; split.
    + discriminate.
    + now   simpl.
  - subst; right with (ocons alpha i gamma).
    +  split.
     *    discriminate.
     *   unfold canonS; rewrite canonSSn.  f_equal.
     --   destruct H1; auto.
     --  auto.
    + apply path_toS_tail; auto.
      apply nf_intro; [auto | | ].
      * destruct H1; subst.
        apply nf_canon; now apply nf_phi0.
      * apply nf_helper_phi0R.
        destruct H1; subst.
        generalize (@canonS_LT i0 (phi0 alpha) (nf_phi0 H)).
        destruct 1.
       -- discriminate.
       -- tauto.
Qed.

Lemma path_to_mult  alpha s i :
  nf alpha ->
  path_to zero  s (phi0 alpha) -> 
  path_to (ocons alpha i zero) s (ocons alpha (S i) zero).
Proof.
  intros Hnf H ; assert (H1:= path_to_not_In_zero H).
  rewrite path_to_path_toS_iff; auto.
  apply path_toS_mult; auto.
  now rewrite <- path_to_path_toS_iff.
Qed.


(** ** Properties of gnaw *)

Lemma gnaw_nf : forall s alpha, nf alpha -> nf (gnaw alpha s).
Proof.
  induction s.
  - intros; now cbn.
  - intros; cbn;  destruct a; auto.
    + apply IHs; apply nf_canon; auto. 
Qed.

Lemma gnaw_zero : forall s, gnaw 0 s = 0.
Proof. 
  induction s; try cbn; auto;  now destruct a.
Qed.

Lemma gnawS_zero : forall s, gnawS zero s = zero.
Proof. 
  induction s; now cbn.
Qed.


Lemma gnawS_nf : forall s alpha, nf alpha -> nf (gnawS alpha s).
Proof.
  induction s.
  - intros; now cbn.
  - intros; cbn; apply IHs;  apply nf_canon;auto. 
Qed.

Lemma gnaw_succ: forall alpha  i s, nf alpha -> 
                                    gnaw (T1.succ alpha) (S i::s) =
                                    gnaw alpha s.
Proof. intros; cbn; now rewrite canon_succ. Qed. 

Lemma gnaw_rw i s alpha : gnaw alpha (S i::s) = gnaw (canon alpha (S i)) s.
Proof. reflexivity. Qed.

Lemma gnawS_to_path_toS : forall s alpha beta,
    beta = gnawS alpha s -> beta <> zero -> s <> nil ->
    path_toS beta s alpha.
Proof.
  induction s;intros alpha beta H H0 H1.
  - now destruct H1.
  - destruct s.
    +  left.
       * split. intro; subst alpha; simpl in H; contradiction.
         simpl in H;now destruct H.
   +  eright.
    * esplit. intro; subst alpha; simpl in H; rewrite gnawS_zero in H;
        contradiction.
      reflexivity.
    *  apply IHs; auto.
       discriminate.
Qed.

Lemma gnaw_to_path_to : forall s alpha beta,
    beta = gnaw alpha s -> ~ In 0 s -> beta <> zero -> s <> nil ->
    path_to beta s alpha.
Proof.
 intros;  rewrite path_to_path_toS_iff; auto.  
   apply gnawS_to_path_toS; auto.
   - now rewrite gnaw_gnawS in H; auto.
   - destruct s.
     + now destruct H2.
     + destruct n.
      * destruct H0; now left. 
      * discriminate.
Qed.

Lemma gnaw_app : forall  s s' alpha,
                   gnaw alpha (s ++ s') = gnaw (gnaw alpha s) s'.
Proof.
  induction s; cbn.
  - trivial.
  - destruct a; auto.
Qed. 

Lemma gnawS_app : forall  s s' alpha,
                   gnawS alpha (s ++ s') = gnawS (gnawS alpha s) s'.
Proof. induction s; cbn; auto. Qed. 

Lemma gnaws_rw i s alpha : gnawS alpha (i::s) = gnawS (canon alpha (S i)) s.
Proof. reflexivity. Qed.


Lemma gnawS_lim1 (i:nat)(s: list nat) (lambda : T1) :
  nf lambda -> limitb lambda ->
  gnawS (ocons lambda 0 T1.zero) (i::s) =
  gnawS (ocons (canon lambda (S i)) 0 T1.zero) s.
Proof.
  intros;  rewrite gnaws_rw.
  unfold canonS;  rewrite canonS_lim1; auto.
Qed.


Lemma gnawS_lim2 (i n:nat)(s: list nat) (lambda : T1) :
  nf lambda -> limitb  lambda->
  gnawS (ocons lambda (S n) T1.zero) (i::s) =
  gnawS (ocons lambda n (ocons (canon lambda (S i)) 0 T1.zero)) s.
Proof.
  intros;   rewrite gnaws_rw. rewrite canonS_lim2; auto.
Qed.



Lemma gnawS_succ_eqn1 i s gamma :
  nf gamma -> gnawS (ocons (T1.succ gamma) 0 T1.zero) (i::s) =
              gnawS (ocons gamma i T1.zero) s.
Proof.
intros;  rewrite gnaws_rw.    rewrite canonS_phi0_succ_eqn; auto.
Qed.


Lemma gnawS_succ_eqn2 :
  forall i n s gamma, nf gamma -> 
                      gnawS (ocons (T1.succ gamma) (S n) zero) (i::s) =
                      gnawS  (ocons  (T1.succ gamma) n
                                     (ocons gamma i T1.zero)) s.
Proof.
  intros; rewrite gnaws_rw.  rewrite canonS_ocons_succ_eqn2;  auto.
Qed.

Lemma gnawS_tail :
  forall i  s alpha n beta,
                  nf (ocons alpha n beta) ->
                  beta <> T1.zero -> 
                  gnawS (ocons alpha n beta) (i::s) =
                  gnawS (ocons alpha n (canon beta (S i))) s.
Proof.
  intros; rewrite gnaws_rw, canon_tail;  auto.
Qed.


Lemma gnawS_SSn (i:nat) s :
  forall alpha n  ,
    nf alpha -> 
    gnawS (ocons alpha (S n) T1.zero) (i::s) =
    gnawS (ocons alpha n (canon (ocons alpha 0 zero) (S i))) s.
Proof.
  intros.  rewrite gnaws_rw; auto.  rewrite canonSSn;  auto.
Qed.

Lemma gnawS_cut1 : forall s alpha n beta,
                    nf (ocons alpha n beta) ->
                    gnawS (ocons alpha n beta) s = T1.zero ->
                    exists s1 s2, s = s1 ++ s2 /\
                                  gnawS beta s1 = zero /\
                                  gnawS (ocons alpha n T1.zero) s2 = zero.
Proof.
  induction s.
  -  intros.
     discriminate H0.  
  -   intros; assert (nf alpha) by eauto with T1.
      assert (nf beta) by eauto with T1.
      destruct (T1_eq_dec beta T1.zero).  
      + subst beta;  exists nil, (a::s); repeat split;auto.
      + rewrite gnaws_rw, canon_tail  in H0; auto.
        destruct (IHs alpha n (canon beta (S a))); auto.
        * apply nf_intro; auto.
          apply nf_canon;auto.
          apply nf_helper_phi0R.
          apply T1.lt_trans with beta.
          apply canonS_lt;auto.
          apply nf_helper_phi0.
          eapply nf_helper_intro; eauto.
        * destruct H3 as [s2 [H4 [H5 H6]]];  exists (a::x), s2.
          subst s; split;auto.
Qed.

Lemma gnawS_cut2 : forall s alpha n ,
                   nf alpha -> 
                   gnawS (ocons alpha (S n) T1.zero) s = zero ->
                   exists s1 s2, s = s1 ++ s2 /\
                                 gnawS (phi0 alpha) s1 = zero /\
                                 gnawS (ocons alpha n T1.zero) s2 = zero.
Proof.
  destruct s. 
  - intros.
    discriminate H0.  
  -  intros.    
     rewrite gnaws_rw in H0.     
     rewrite canonSSn in H0; auto.
     destruct (T1_eq_dec alpha T1.zero).
     + subst; exists (n::nil), s;  split;auto.
     + destruct (@gnawS_cut1 s alpha n0 (canon (phi0 alpha) (S n))).
       2 : auto.
       rewrite <- canonSSn; auto.
         apply nf_canon;auto.
       * destruct H1 as [s2 [H2 [H3 H4]]];exists (n::x), s2;  split;auto.
         now subst.
Qed.


Lemma path_to_gnaw : forall s alpha beta,  
    path_to beta s alpha ->
    beta = gnaw alpha s.
Proof.
  intros.
   assert (H0: ~ In 0 s). { now apply path_to_not_In_zero in H. }
  generalize (unshift_shift  s H0); intro e.
  rewrite  gnaw_gnawS; apply path_toS_gnawS.
  now apply path_to_path_toS in H. 
Qed.


Lemma gnawS_path_toS : forall s alpha , s <> nil -> gnawS alpha s <> zero ->
                                        path_toS (gnawS alpha s) s alpha.
Proof.
  induction s.
  - now destruct 1.
  - destruct s.
    +  left.
       split. intro; subst.
       simpl in H0.
       now destruct H0.
       reflexivity.
    + intros alpha _;  eright.
      esplit. intro; subst.
      apply H.
      now rewrite gnawS_zero.
      reflexivity.
      * apply IHs; auto.  discriminate.
Qed.

Lemma gnaw_path_to : forall s alpha , s <> nil -> ~ In 0 s ->
                                      gnaw alpha s <> zero ->
                                      path_to (gnaw alpha s) s alpha.
  intros s alpha H H0.
  replace s with (shift (unshift s)).        
  2: apply unshift_shift; assumption.   
  rewrite <- gnawS_gnaw.
  intros; apply path_toS_path_to.
  apply gnawS_path_toS; auto.
  clear alpha H1.
  revert H  H0.
  induction s; simpl; auto.
  destruct a.
  tauto.
  discriminate.
Qed.



(** **  Properties of acc_from  *)


Lemma acc_from_trans : forall alpha beta gamma,
    acc_from alpha beta -> acc_from beta gamma -> acc_from alpha gamma.
Proof.      
  destruct 1 as [s1 H1].
  destruct 1 as [s2 H2].
  exists (s1 ++ s2).
  now apply path_to_app with beta.
Qed.


Lemma LT_path_toS (alpha beta : T1) :
  beta t1< alpha -> {s : list nat | path_toS beta s alpha}.
Proof with eauto with T1.
  transfinite_induction alpha;
    clear alpha; intros alpha IHalpha H.
  assert (H0: nf beta) ...
  assert (H1: nf alpha) ...
  destruct (zero_limit_succ_dec H1 ) as [[Hzero | Hlimit] | Hsucc].
  -  (* alpha = 0 *)
    subst alpha;  destruct (not_LT_zero H).
  -  (* alpha is a limit ordinal *)
    destruct  (canonS_limit_strong H1 Hlimit H) as [j Hj].
    destruct (IHalpha (canon alpha (S j))) as [x p]; auto.
    apply canonS_LT; auto.
    apply limitb_not_zero;auto.
    exists (j::x); eright.
    {split. intro;  subst.
     - inversion  Hlimit.
     - reflexivity. }
    assumption.
  -  (* alpha is a successor *)
    destruct Hsucc as [gamma [H3 H2]].
    subst alpha; destruct (LT_succ_LT_eq_dec H0 H3 H).
    +   destruct (IHalpha gamma) as [x p]; auto.
        apply LT_succ; auto.
        exists (0::x); right with gamma; auto.
        split.
        * apply succ_not_zero.
        * now rewrite canon_succ.
    +   subst beta; exists (0::nil); left.
        *  split.
           -- apply succ_not_zero.
           -- now rewrite canon_succ.
Defined.

Lemma LT_path_to (alpha beta : T1) :
  beta t1< alpha -> {s : list nat | path_to beta s alpha}.
Proof.
  intro H; destruct (LT_path_toS H) as [s Hs]; exists (shift s);
    now rewrite <- path_toS_path_to.
Defined.

(*
From Coq Require Import Extraction.
Recursive Extraction LT_path_to.
 *)

Lemma LT_acc_from (alpha beta : T1) :
  beta t1< alpha -> acc_from alpha beta.
Proof.
  intro H; destruct (LT_path_toS H);  apply  path_acc_from with (map S x).
  now apply path_toS_path_to.  
Qed.


Lemma path_toS_LT beta s alpha: 
  path_toS beta s alpha -> nf alpha -> beta t1< alpha.
Proof.
  induction 1.
  destruct H.
  intro; subst; now apply canonS_LT.
  intro; apply LT_trans with gamma; auto.
  apply IHpath_toS.
  destruct H;subst.
  now   apply nf_canon.
  destruct H.
  subst; apply canonS_LT; auto.   
Qed.

Lemma path_to_LT beta s alpha :
  path_to beta s alpha -> nf alpha -> beta t1< alpha.
Proof.
  intro H; assert (H0 := path_to_not_In_zero  H).
  rewrite path_to_path_toS_iff in H.
  intro; eapply path_toS_LT; eauto.
  auto.
Qed.



Lemma acc_from_LT (alpha beta : T1) :
  acc_from alpha beta ->  nf alpha ->   beta t1< alpha.
Proof.
  destruct 1 as [s Hs]; intro; eapply path_to_LT; eauto.
Qed.


(** ** Paths with constant index: lemmas *)

Lemma const_pathS_repeat i : forall alpha  beta,
    const_pathS i alpha beta ->
    exists n:nat, path_toS beta (repeat i (S n)) alpha.
Proof.  
  induction 1.
  - exists 0;  now left.
  - destruct IHclos_trans_1n as [n Hn]; exists (S n); now right with y.
Qed.      


Lemma const_pathS_repeatR i : forall n  alpha beta,
    path_toS beta (repeat i (S n)) alpha -> 
    const_pathS i alpha beta.
Proof.  
  induction n.
  - left; now inversion_clear H.
  - inversion_clear 1.
    right with gamma; auto; apply IHn; auto.
Qed.

Lemma const_pathS_nf : forall n alpha beta, 
    const_pathS n alpha beta ->
    nf alpha -> nf beta.
Proof.
  induction 1. 
  - destruct H; subst; intro; apply nf_canon;auto. 
  - intro; apply IHclos_trans_1n; subst.
    destruct H. subst; apply nf_canon;auto.
Qed.

Lemma const_pathS_zero n alpha : ~ const_pathS n zero alpha.
Proof.
  intros  H; red in H. rewrite <- clos_trans_t1n_iff in H;
      rewrite clos_trans_tn1_iff in H;
      induction H;  now subst.
Qed.


Lemma const_pathS_LT i  alpha beta:  (* alpha <> zero -> *)
                                     nf alpha ->
                                     const_pathS i alpha beta ->
                                     beta t1< alpha.
Proof.
  intros  H0 H1; apply acc_from_LT;auto.
  - destruct (const_pathS_repeat H1) as [x H2].
    apply path_toS_path_to in H2.
    apply (path_acc_from H2); auto.
Qed.

Lemma const_path_LT i :
  forall alpha beta,
      nf alpha -> const_path i alpha beta ->
    beta t1<  alpha.
Proof.
  destruct i as [| i].
  -  intros alpha beta H0 H1; inversion H1.
  -  intros; apply const_pathS_LT with i;   auto. 
Qed.


Lemma const_pathS_LE i : forall alpha beta, 
    nf alpha -> const_pathS i alpha beta ->
    beta  t1<= alpha.
Proof.
  intros; apply LE_r; eapply const_pathS_LT; eauto.
Qed.


Lemma const_pathS_inv : forall n alpha beta,
    const_pathS n alpha beta ->
    beta = canon alpha (S n) \/
    const_pathS n (canon alpha (S n)) beta.
Proof.
  inversion 1; destruct H0.
  - left; congruence.
  - right; subst; auto.
Qed.

Lemma const_pathS_inv_strong : forall n alpha beta,
    const_pathS n alpha beta ->
    {beta = canon alpha (S n)} +
    {const_pathS n (canon alpha (S n)) beta}.
Proof.
  intros n alpha beta H; destruct (T1_eq_dec beta (canon alpha (S n))).
  - left;auto.
  - right;  destruct (const_pathS_inv H).
    +  contradiction.
    +  trivial.
Qed.


Lemma const_pathS_trans : forall n alpha beta gamma,
    const_pathS n alpha beta ->
    const_pathS n beta gamma ->
    const_pathS n alpha gamma.
Proof.                    
  unfold const_pathS; intros n alpha beta gamma H H0;                       
    rewrite <-  clos_trans_t1n_iff in *;
    constructor 2 with beta; assumption.
Qed.

Lemma const_pathS_eps_trans : forall i alpha beta gamma,
    const_pathS_eps i alpha beta -> 
    const_pathS_eps i beta gamma ->
    const_pathS_eps i alpha gamma .
Proof. 
  destruct 1.
  - destruct 1.
    + left; eapply const_pathS_trans; eauto. 
    +  subst; now left. 
  -  trivial. 
Qed.

Lemma const_pathS_eps_LE_2 : forall n alpha beta,
    nf alpha -> nf beta ->
    const_pathS_eps n alpha beta ->
    beta t1<=  alpha.
Proof. 
  destruct 3.                                           
  - eapply const_pathS_LE; eauto. 
  - subst; apply LE_refl; auto.
Qed. 


Lemma Proposition_2_3a:  (* KS paper, p 281 *)
  forall n alpha , nf alpha -> alpha <> zero ->
                   forall beta gamma,   LT gamma  beta ->
                                        const_pathS n alpha gamma ->
                                        const_pathS n alpha beta ->
                                        const_pathS n beta gamma.
Proof.
  intros n alpha; transfinite_induction alpha.
  clear alpha ;  intros alpha Hrec H H' beta gamma H0 H1 H2.
  destruct (const_pathS_inv H1), (const_pathS_inv H2).
  - subst; destruct (LT_irrefl H0).
  - destruct (T1_eq_dec alpha zero).
    + now destruct H'. 
    + subst gamma; elimtype False.
      apply const_pathS_LE in H4.
      destruct (@LT_irrefl beta).
      eapply LE_LT_trans;eauto.
      apply nf_canon;auto.
  - subst beta;  auto.
  - destruct (T1_eq_dec alpha zero).
    +  subst alpha.  destruct (const_pathS_zero H2). 
    + apply (Hrec (canon alpha (S n))); auto.
      apply canonS_LT; auto. 
      apply nf_canon;auto.
      intro H5;rewrite H5 in H4.
      inversion_clear  H4; destruct H6; auto.
Qed.

Lemma KS_thm_2_4_lemma1 : forall i alpha n beta beta',
    nf (ocons alpha n beta) ->
    beta <> zero ->
    const_pathS i beta beta' ->
    const_pathS i (ocons alpha n beta)
            (ocons alpha n beta').
Proof.
  induction 3.
  - destruct H1; subst; left; now  rewrite canon_tail.
  -  destruct H1; subst;  destruct (T1_eq_dec (canon x (S i)) zero).    
     { rewrite e in *; destruct (const_pathS_zero H2). }
     { constructor 2 with (ocons alpha n (canon x (S i))).  
       - now  rewrite canon_tail.
       - apply IHclos_trans_1n; auto. 
         + apply nf_LT_right with x;auto. 
           apply canonS_LT; trivial.
           eapply nf_inv2, H. 
     }
Qed.

Lemma const_pathS_first_step : forall i alpha beta,
    const_pathS i alpha beta ->
    {beta = canon alpha (S i) } +
    {const_pathS i (canon alpha (S i)) beta}.
Proof.     
  intros; destruct (T1_eq_dec beta (canon alpha (S i))).
  - now left.   
  -  right;  generalize n; induction H.
     +   destruct n;auto. tauto.
     + intros; destruct H;  now  subst y. 
Qed.    

Lemma KS_thm_2_4_lemma1' : forall i alpha n beta ,
    nf alpha ->  alpha <> zero ->
    const_pathS i (phi0 alpha)  beta ->
    const_pathS i (ocons alpha (S n) zero)
                (ocons alpha n  beta).
Proof with auto with T1.
  intros i alpha n beta H H0 H1;  destruct (zero_limit_succ_dec H). 
  - destruct s. 
    +  now destruct H0.
    +  destruct (const_pathS_first_step H1).
       { rewrite  e; left;  split.
         discriminate. rewrite canonSSn ; trivial. }
       { apply const_pathS_trans with
             (ocons alpha n (phi0 (canon alpha (S i)))) ; trivial. 
         { left;  rewrite canonSSn ; eauto with T1.
           - split.
             + discriminate.
             + rewrite canonS_lim1 ; eauto with T1.
         }
         apply KS_thm_2_4_lemma1. 
         - apply nf_ocons_LT; trivial.
           apply canonS_LT ; eauto with T1.
           apply single_nf ; trivial. 
           now apply nf_canon.
         - discriminate. 
         - unfold canonS in c; rewrite canon_lim1 in c ; eauto with T1.
       }      
  - destruct s as [gamma [H2 H3]]; destruct (const_pathS_first_step H1).
    { 
      unfold canonS in e; rewrite e; left; subst alpha; (* unfold T1.phi0. *)
      repeat rewrite canonS_phi0_succ_eqn; trivial.
       now rewrite canonS_ocons_succ_eqn2. 
    }
    apply const_pathS_trans with (ocons alpha n (ocons gamma i zero)).
    left; subst alpha; rewrite canonS_ocons_succ_eqn2 ; eauto with T1. 
    split; [discriminate |]. reflexivity. apply KS_thm_2_4_lemma1 ; trivial. 
    apply nf_ocons_LT ; eauto with T1.
    + subst; apply LT_succ ; eauto with T1. 
    +   discriminate. 
    +  subst alpha. unfold canonS in c; rewrite  canonS_phi0_succ_eqn in c; auto. 
Qed.

Lemma KS_thm_2_4_lemma2 (n:nat)(alpha:T1) :
  nf alpha -> alpha <> zero -> const_pathS n alpha zero.
Proof.
  transfinite_induction alpha; clear alpha; intros alpha hrec Halpha.
  destruct (zero_limit_succ_dec Halpha).
  -  destruct s.
     +  intro; contradiction.
     + intros;  specialize (hrec (canon alpha (S n)));
        constructor 2 with (canon alpha (S n)).
        * split;trivial.
        *  apply hrec.
            -- apply canonS_LT;auto.
            -- eapply nf_canon; eauto. 
            -- now apply limitb_canonS_not_zero.
  - destruct s as [beta [Hbeta e]]; subst.
    destruct (T1_eq_dec beta zero).
   + subst;    left; split; auto.  
   + right with beta.
     * split;  auto. now rewrite canon_succ.
     * apply hrec; auto with T1.
       now apply LT_succ.
Qed. 

Lemma KS_thm_2_4_lemma3_0 : forall i alpha n,
    nf alpha ->
    const_pathS i (ocons alpha (S n)  zero)
            (ocons alpha n zero).
Proof.
  intros i alpha n H;  destruct (zero_limit_succ_dec H).
  - destruct s.
    +  subst.   left.   split; [discriminate | reflexivity].
    +  right with (canon (ocons alpha (S n) zero) (S i)).
       *  split; [discriminate | reflexivity].
       * unfold canonS; rewrite canonS_lim2;auto.
         eapply KS_thm_2_4_lemma1; auto.
         -- apply ocons_nf; auto.
            ++ apply canonS_lt; auto.
               intro; subst; discriminate.
            ++ apply single_nf;  apply nf_canon; auto.
         -- discriminate.
         -- apply KS_thm_2_4_lemma2.
         ++ apply single_nf. 
            apply nf_canon; auto.
         ++ discriminate.
  - destruct s as [beta [Hbeta e]]; subst.
    right with (canon (ocons (T1.succ beta) (S n) zero) (S i)).
    +  split; [discriminate | reflexivity].
    +  unfold canonS; rewrite canonS_ocons_succ_eqn2;auto.
       eapply KS_thm_2_4_lemma1; auto.
       * apply ocons_nf; auto. 
         apply lt_succ; auto. 
       *  discriminate.
       *  apply KS_thm_2_4_lemma2;  auto with T1.
          discriminate.
Qed.

(* Lemma 3 of Theorem 2.4 in [K-S] *)

Lemma KS_thm_2_4_lemma3 : forall i n p alpha ,
    nf alpha -> n < p ->
    const_pathS i (ocons alpha p zero)
            (ocons alpha n zero).
Proof.
  induction 2.
  - apply KS_thm_2_4_lemma3_0; auto.
  - apply const_pathS_trans with  (ocons alpha  m zero); auto. 
    + apply KS_thm_2_4_lemma3_0; auto.   
Qed.

Lemma KS_thm_2_4_lemma4 : forall i alpha,
    nf alpha ->
    const_pathS i (phi0 (succ alpha)) (phi0 alpha).
Proof.
  destruct i.
  - intros; left;  rewrite canonS_phi0_succ_eqn; auto.
    split; [discriminate | reflexivity].
  -  intros; right with (canonS (phi0 (T1.succ alpha)) (S i)).
     + rewrite canonS_phi0_succ_eqn; auto. unfold canonS.
       split; [discriminate | ].
       rewrite canonS_phi0_succ_eqn; auto.
     + unfold canonS.
       rewrite canonS_phi0_succ_eqn; auto.
         apply KS_thm_2_4_lemma3; auto with arith.
Qed.


Lemma KS_thm_2_4_lemma5 : forall i alpha beta,
    const_pathS i alpha beta -> nf alpha ->
    alpha <> zero -> 
    const_pathS i (phi0 alpha) (phi0 beta).
Proof.
  induction 1.
  {
    destruct H as [H e]; subst y; intros.
    destruct (zero_limit_succ_dec H0).
    - destruct s.
      + subst x; now destruct H1.
      +   left;  now rewrite canonS_lim1.
    -  destruct s as [beta [H2 e]]; subst.
       rewrite canon_succ; auto.
       * now apply KS_thm_2_4_lemma4.
  }
  {   destruct H as [H e];subst y; intros.
      destruct (zero_limit_succ_dec H1).
      - destruct s.
        + subst x; now destruct H2.
        + right with (phi0 (canon x (S i))).
          *  rewrite canonS_lim1; auto.
            split;[discriminate | trivial].
          *   apply IHclos_trans_1n.
              apply nf_canon;auto.
              apply limitb_canonS_not_zero; auto.
      -  destruct s as [beta [H3 e]]; subst x.
         destruct (T1_eq_dec beta zero).
         { subst beta; destruct (const_pathS_zero H0). }
           rewrite canon_succ in IHclos_trans_1n; auto. 
           apply const_pathS_trans with (phi0 beta); auto.
           + apply KS_thm_2_4_lemma4; auto. 
  }
Qed.

Theorem KS_thm_2_4 (lambda : T1) :
   nf lambda ->
   limitb lambda  ->
   forall i j, (i < j)%nat ->
               const_pathS 0 (canon lambda (S j))
                             (canon lambda (S i)).
Proof.
   transfinite_induction lambda.
  clear lambda ; intros alpha Hrec Halpha H.
  destruct (zero_limit_succ_dec Halpha).
  - destruct s.
    + subst;  discriminate.
    + destruct alpha.
      * discriminate.
      *  nf_decomp Halpha.
         destruct (limitb_cases Halpha  H).
         { destruct a; subst alpha2.
           intros i0 j H1;  destruct (@zero_limit_succ_dec alpha1) ;
             trivial.
           destruct s.
           {subst. now contradict H0. }
           { induction n.
             - repeat rewrite canonS_lim1; auto.
               apply KS_thm_2_4_lemma5. 
               apply Hrec ; trivial.
               split ; trivial. 
               split ; trivial.
               apply head_lt_ocons ; trivial.
               apply nf_canon ; eauto with T1. 
               apply limitb_canonS_not_zero ; eauto with T1.
             - repeat rewrite canonS_lim2 ; eauto with T1.
                apply KS_thm_2_4_lemma1 ; trivial. 
                apply ocons_nf ; trivial. 
                apply canonS_lt ; trivial.
                apply single_nf.   
                apply nf_canon ; eauto with T1.
                discriminate.
                apply KS_thm_2_4_lemma5 ; trivial.
                apply Hrec ; eauto with T1.
                split ; eauto with T1.
                split.
                apply  head_lt_ocons ; eauto with T1.
                apply single_nf ; eauto with T1.
                apply nf_canon ; eauto with T1.
                apply limitb_canonS_not_zero ; eauto with T1.
           }
           destruct s as [beta [H2 H3]];  subst; clear H i; induction n.
           {
             repeat rewrite  canonS_phi0_succ_eqn ; eauto with T1.
             apply KS_thm_2_4_lemma3 ; eauto with T1.
           }
           { 
             repeat rewrite  canonS_ocons_succ_eqn2 ; eauto with T1.
             apply KS_thm_2_4_lemma1 ; trivial. 
             apply ocons_nf ; trivial.
             apply lt_succ; auto.
             discriminate. 
             apply KS_thm_2_4_lemma3 ; eauto with T1.
           }
         }
         intros i0 j H0; destruct a.
         repeat rewrite canon_tail ; eauto with T1.
         apply KS_thm_2_4_lemma1 ; trivial. 
         apply nf_LT_right with alpha2 ; eauto with T1.
         apply canonS_LT ; eauto with T1.
         apply limitb_canonS_not_zero ; eauto with T1.
         apply Hrec ; eauto with T1.
         split ; eauto with T1.
         split ; eauto with T1.
         apply  tail_lt_ocons; auto.
         all: intro; subst; discriminate.
  -  destruct s as [beta [H0 H1]]; 
       subst; destruct (@limitb_succ beta); auto. 
Qed.

(**  Corollary 12 of [KS] *)

Corollary Cor12 (alpha : T1) :  nf alpha ->
                forall beta i n, beta  t1< alpha  ->
                                 i < n ->
                                 const_pathS i alpha beta ->
                                 const_pathS n alpha beta.
Proof.
  transfinite_induction_lt alpha.
  clear alpha ; intros alpha Hrec Halpha; intros.
  destruct (zero_limit_succ_dec   Halpha).
  -  destruct s.
    + subst; destruct (not_LT_zero H).

    + (* alpha limit *)
      destruct  H1.
      {  destruct H1 as [H1 e]; subst y.
         assert (H2: const_pathS 0 (canon alpha (S n)) (canon alpha (S i))).     
         {  apply KS_thm_2_4;  auto. }
         constructor 2 with (canonS alpha n).
         - split ; auto.
         - apply Hrec with 0; auto.
           +  apply nf_canon;   auto. 
           + apply canonS_lt; auto.
           + apply  nf_canon; auto.
           + apply canonS_limit_mono; auto.
           + apply Nat.le_lt_trans with i;  auto with arith.
      }
      {     
        (*   alpha -i->  y= canonS i alpha -i-+->  z *)
        destruct H1 as [H01 H1];
          subst y;   assert (const_pathS n (canon alpha (S i)) z).
        {
          apply Hrec with i;auto.
          apply nf_canon;   auto.
          apply canonS_lt;auto.
          apply nf_canon; auto.
          eapply const_pathS_LT.
          apply nf_canon; auto.
          eapply H2.
        }
        {
          red; rewrite <- clos_trans_t1n_iff.
          apply t_trans with (canon alpha (S n)).
          left.
          auto.
          right with (canon alpha (S i)).
          rewrite  clos_trans_t1n_iff.
          apply Hrec with 0;eauto.
          now apply nf_canon.
          apply canonS_lt; auto.
          apply nf_canon; auto.
          apply  canonS_limit_mono ;auto.
          apply Nat.le_lt_trans with i;auto.
          auto with arith.
          apply KS_thm_2_4; auto.
          now rewrite  clos_trans_t1n_iff.
        }
      }
  - destruct s as [x [H2 H3]]; subst alpha.
    { destruct H1.
      -  destruct H1 as [H01 H1] .
         subst y.
         rewrite canon_succ.
         left.
         rewrite canon_succ;auto.
         auto.
      -  destruct H1 as [H01 H1]; subst y; rewrite canon_succ in H3.
         right with x.
         + rewrite canon_succ;auto.
         + destruct (T1_eq_dec x zero). 
           {
             subst x; auto. 
             assert (z = zero).
             {
               simpl succ in H; apply LT_one in H; auto. 
             }
             constructor 1.
             subst. 
             split; auto. 
             inversion_clear H3.
             now destruct H1.
             now destruct H1.
           }
           apply Hrec with i;eauto.
           apply lt_succ.
           eapply const_pathS_LT;eauto.
         + auto. 
    }
Qed.

Corollary Cor12_1 (alpha : T1) :
  nf alpha ->
  forall beta i n, beta t1< alpha ->
                   i <= n ->
                   const_pathS i alpha beta ->
                   const_pathS n alpha beta.
Proof.
  intros H beta i n H0 H1 H2; destruct (Lt.le_lt_or_eq _ _ H1).
  -   eapply Cor12;eauto.
  -   now subst.
Qed.

Corollary Cor12_2 (alpha : T1) : 
    nf alpha ->
    forall beta i n,
      i <= n ->
      const_pathS_eps i alpha beta ->
      const_pathS_eps n alpha beta.
Proof.
  intros H beta i n H0; destruct (T1_eq_dec  alpha beta).
  -  subst;now right. 
  -  destruct 1.
     + left; apply Cor12_1 with i;auto.
       apply const_pathS_LE in H1; auto.
      * destruct (LE_LT_eq_dec H1);auto.
        subst; now destruct n0.
     + now destruct n0.
Qed. 


Corollary Cor12_3 (alpha : T1) :
  nf alpha ->
  forall beta i n, beta t1< alpha ->
                   i <= n ->
                   const_path i alpha beta ->
                   const_path n alpha beta.
Proof.
  destruct i, n.

  - auto.
  - inversion 3.
  - inversion 2.
  - intros; eapply Cor12_1 with i;eauto with arith.
Qed.


Lemma const_pathS_eps_zero n alpha :
   const_pathS_eps n zero alpha ->  alpha = zero.
Proof. 
  destruct 1; auto; now apply const_pathS_zero in H.
Qed. 

(* Lemma 1, Section 2.6 *)

Lemma Lemma2_6_1 (alpha : T1) :
  nf alpha ->
  forall beta,
    beta t1< alpha  ->
    {n:nat | const_pathS n alpha beta}.
Proof.
  transfinite_induction alpha.
  intros x H Hx; destruct (zero_limit_succ_dec Hx).
  - destruct s.
   + subst;  intros.  destruct (not_LT_zero H0).  
   +  intros beta H0;  destruct (canonS_limit_strong Hx i H0) as [n1 H1].
     assert (canon x (S n1) t1< x)%t1. 
     { apply canonS_LT; auto.
       intro; subst; discriminate. }
     assert (nf (canon x (S n1))).
      {  eapply nf_canon;eauto. }
      destruct (H (canon x (S n1)) H2 H3 beta) as [n2 Hn2].
      * auto.
      * exists (Nat.max n1 n2); red;rewrite  <- clos_trans_t1n_iff.
        constructor 2  with (canon x (S n1)).
       --  rewrite  clos_trans_t1n_iff.
           apply Cor12_1 with n1; auto.
           auto with arith.   
           left.
           split.
           ++ intro e;subst. 
              destruct (@limitb_not_zero zero) ; auto.
           ++ reflexivity. 
       -- rewrite  clos_trans_t1n_iff;  apply Cor12_1 with n2; auto.
          auto with arith.  
  -   intros beta H0.
      destruct s as [x0 [H1 H2]].
      subst.
      assert (Hx0: (x0 t1< T1.succ x0)%t1) by (apply LT_succ ;auto).
      assert ({beta t1< x0} + { beta = x0})%t1.
      { apply LT_succ_LT_eq_dec in H0; trivial. eauto with T1.
      }  
      destruct H2. 
    + destruct (H x0 Hx0 H1 beta l) as [n Hn]; exists n.
      right with x0.
      *  rewrite canon_succ.
       -- split.
        ++ apply succ_not_zero.
        ++ auto.
       --   assumption.
      * assumption.
    +  exists 1; subst;left.
       rewrite canon_succ; trivial.
     *  split; trivial.
        -- now apply succ_not_zero.
Defined.

Lemma small_lemma (i:nat) (beta : T1) :  forall alpha,
      const_pathS i alpha beta ->
      nf alpha -> 
      beta t1<= canon alpha (S i).
Proof.
  destruct (T1_eq_dec beta zero).
  -  subst; intros; apply LE_zero; auto with T1.
     apply nf_canon; auto with T1. 
  - induction 1.
    +  intros;   destruct H; subst.   apply LE_refl.  auto with T1.
       apply nf_canon; auto with T1. 
    + destruct H;  subst; intro;
        apply LE_trans with (canon (canon x (S i)) (S i)).
       * apply IHclos_trans_1n; auto.
         apply nf_canon; auto.
       * apply LE_r, canonS_LT.
         { apply nf_canon; auto. }
         { intro H2.  rewrite H2 in H0.
           apply const_pathS_zero in H0. 
           now destruct n.
         }
Qed.


Lemma L2_6_2 (p: nat)  :
  forall alpha, nf alpha ->
                forall beta, const_pathS p alpha beta ->
                             T1.succ beta t1< alpha -> 
                             const_pathS (S p) alpha (T1.succ beta).
Proof.                                                                
  intros  alpha ; transfinite_induction alpha.
  clear alpha ; intros alpha HRecAlpha Halpha .
  intros;assert (beta t1<= canon alpha (S p))%t1.
  -   apply small_lemma; auto. 
  -   destruct (LE_LT_eq_dec H1).
    +   assert (T1.succ beta t1<= canon alpha (S p))%t1.
        { apply   LT_succ_LE;auto. }
        destruct (LE_LT_eq_dec H2).
        *   specialize (HRecAlpha (canon alpha (S p)) ).
            assert (canon alpha (S p) t1< alpha)%t1.
            {   apply canonS_LT; auto.
                intro; subst alpha; destruct (not_LT_zero H0).
            }
            apply const_pathS_trans  with (canon alpha (S p)).
            { apply Cor12 with p; auto.
              left; split.
                intro H4;subst; destruct (not_LT_zero H0).
                reflexivity. }
            { apply HRecAlpha.
              apply canonS_LT; auto with T1.
              intro; subst. 
              destruct (not_LT_zero H0).
              destruct H3;tauto.
              apply  Proposition_2_3a with alpha; trivial.
                  intro H4; subst.
                 destruct (not_LT_zero H0).
                 left.
                 split.
                 intro; subst. 
              destruct (not_LT_zero H0).
              reflexivity.
              auto.
            }
        * rewrite e;  apply Cor12 with p; auto. 
          apply canonS_LT; auto with T1.
          intro; subst alpha. 
          destruct (not_LT_zero H0).
          left.
          split.
           intro;subst; destruct (not_LT_zero H0).
          trivial.
    +  clear H1;  destruct alpha. 
       { destruct (not_LT_zero H0). }
       {  destruct n. 
          destruct alpha2.
          nf_decomp Halpha.
          destruct (@zero_limit_succ_dec alpha1);  trivial.
          destruct s.
          subst; cbn in H0.
          destruct (LT_irrefl H0).
          rename alpha1 into lambda.    
          rewrite canonS_lim1 in e.
          assert (const_pathS  p lambda (canon lambda (S p))).
          left.
            split.
            intro;subst.
           destruct (@limitb_not_zero zero); trivial. 
           trivial.
          assert (const_pathS  (S p) lambda (T1.succ (canon  lambda (S p)))).
          {
            apply HRecAlpha;auto. 
            apply head_LT_cons; eauto with T1.
            apply succ_lt_limit; auto. 
            apply canonS_LT;auto with T1. 
          }
          apply const_pathS_trans
            with (ocons (T1.succ  (canon lambda (S p))) 0 zero); eauto with T1.
          apply KS_thm_2_4_lemma5; trivial. auto with T1.
          apply HRecAlpha; trivial. 
          apply LT2.
          apply single_nf.
          apply succ_nf.
          apply nf_canon.
          assumption.
          apply single_nf; eauto with T1.
          apply succ_lt_limit; auto. 
          apply canonS_LT;auto with T1. 
          apply succ_nf;  apply nf_canon; eauto with T1.
          subst; apply KS_thm_2_4_lemma5; trivial.
          left;  rewrite canon_succ; auto.
          split.
          apply succ_not_zero; auto.
          trivial.
          apply nf_canon; eauto with T1.
          apply succ_nf;  apply nf_canon; eauto with T1.
          apply succ_not_zero.
          rewrite e;  apply succ_lt_limit; auto. 
          apply single_nf; trivial. 
          apply succ_nf;  apply nf_canon; eauto with T1.
          simpl; case_eq (T1.succ (canon lambda (S p))).
          intro; destruct (succ_not_zero (canon lambda (S p))); auto. 
          auto. 
          apply LT2; trivial.
          apply single_nf; trivial. 
          apply nf_canon; eauto with T1.
          apply single_nf; trivial. 
          apply succ_nf;  apply nf_canon; eauto with T1.
          apply LT_succ.
          apply nf_canon; eauto with T1.
          eauto with T1.
          auto.
          
          (* end of the limitb case *)
          {
            destruct s as [gamma [H1 H2]];destruct (T1_eq_dec gamma zero).
            {
              (** cas limite *)
              subst gamma alpha1; simpl in e;   subst beta;    left. 
              split. discriminate. rewrite canonS_phi0_succ_eqn;    trivial.
              
            }
            assert ( beta = ocons gamma p zero).
            { rewrite e, H2; now rewrite canonS_phi0_succ_eqn. }
            apply const_pathS_trans with (ocons gamma (S p) zero).
            { left; rewrite H2; now rewrite canonS_phi0_succ_eqn. }
            apply HRecAlpha.
            - subst alpha1; apply LT2. 
              apply single_nf; auto with T1.
              apply single_nf; trivial.
              apply LT_succ; auto. 
            - apply single_nf;auto. 
            -  rewrite H3.
               apply KS_thm_2_4_lemma3_0; auto. 
            -  apply succ_lt_limit; eauto with T1.
               cbn;  destruct gamma.
               +   now destruct n.
               +   auto. 
               +  rewrite H3; apply LT3; auto with arith.
          }
          { (** recursive case on tail :  *)
            rewrite canon_tail in e.
            - subst beta; destruct (T1_eq_dec alpha2_1 zero).
              {
                subst alpha2_1;  assert (alpha2_2 = zero).
                { 
                  apply nf_inv2 in Halpha; now  apply nf_of_finite in Halpha.
                }  
                subst alpha2_2; simpl canonS; destruct n.
                simpl in H0.
                destruct alpha1.
                destruct H0.    
                destruct H1.
                discriminate H1.
                destruct (LT_irrefl H0).
                simpl in H0.
                destruct alpha1.
                destruct n.
                generalize (nf_of_finite Halpha); discriminate.
                generalize (nf_of_finite Halpha); discriminate.
                destruct (LT_irrefl H0).
              }
              rewrite succ_ocons.
              + apply KS_thm_2_4_lemma1; eauto with T1.
                discriminate.
                apply HRecAlpha; trivial.
                apply LT2; eauto with T1.
                split; eauto with T1.
                eapply nf_inv2, Halpha.
                now left.
                rewrite succ_ocons in H0.
                apply remove_first_sumand in H0.
                auto.
                destruct alpha2_1.
                destruct n0; auto.
                { cbn. destruct n, alpha2_2, alpha2_1_1, n1;
                         try discriminate.
                  all:  destruct (T1.pred alpha2_1_2); try discriminate.
                }
                apply nf_LT_right with (ocons alpha2_1 n alpha2_2).
                eapply Halpha.
                apply canonS_LT; trivial.  eauto with T1.
                discriminate.
              + eapply canonS_cons_not_zero; eauto. 
              +  eapply nf_LT_right; eauto.
                 apply canonS_LT;  trivial. eauto with T1.
                 discriminate. 
            -  eauto with T1. 
            -  discriminate. 
          }
          destruct (T1_eq_dec alpha2 zero).
          { 
            subst alpha2;  rewrite canonSSn in e.
            destruct (T1_eq_dec alpha1 zero).
            {
              subst alpha1; simpl canonS in e;  subst beta;
                simpl in H0.
              destruct (LT_irrefl H0).
            }
            rewrite e,  succ_ocons.
            apply KS_thm_2_4_lemma1'.
            eauto with T1.
            auto. 
            apply HRecAlpha.
            apply LT3; auto with arith. 
            eauto with T1.
            now left. 
            apply succ_lt_limit; eauto with T1.
            cbn;   destruct alpha1; auto.
            apply canonS_LT; trivial.
            discriminate. 
            apply canonS_cons_not_zero; auto.
            apply nf_intro. 
            eauto with T1.
            apply nf_canon; eauto with T1.
            apply nf_helper_phi0R.
            destruct (@canonS_LT p (ocons alpha1 0 zero)).
            eauto with T1.
            discriminate. 
            destruct H2;auto. 
            eauto with T1. 
          }
          
          rewrite canon_tail in e; auto.
          rewrite e; simpl succ; destruct alpha1.
          apply nf_of_finite in Halpha.
          now destruct n0.
          apply   KS_thm_2_4_lemma1; auto. 
          rewrite e in H0.
          cbn in H0; apply remove_first_sumand in H0.
          apply HRecAlpha; auto. 
          apply tail_LT_cons; auto. 
          eauto with T1.
          now left. 
       }
Qed.

Section Lemma_4_3_Proof.
  Variables alpha beta : T1.
  Hypothesis H00 : alpha <> zero.
  Hypothesis nf1 : nf alpha.
  Hypothesis nf2 : nf beta.
  Variables n0 n1 n2: nat.
  Hypothesis H0: (n0 <=n2)%nat.
  Hypothesis H1: (n1 <=n2)%nat.
  Hypothesis H4: const_pathS_eps n0 alpha beta.

  Remark R4_3_1: const_pathS_eps n2 alpha beta.
  Proof.
    destruct H4.
    - left;  apply Cor12_1 with n0; auto. 
      eapply const_pathS_LT;eauto.    
    - subst;now right. 
  Qed. 

  Remark R4_3_2 : const_pathS_eps n2 beta (canon beta (S n1)).
  Proof.
    destruct (T1_eq_dec beta zero).
    - subst;  cbn;  now right. 
    -  left;  apply Cor12_1 with n1; auto. 
       + apply canonS_LT; auto. 
       +  left.  split; auto. 
  Qed. 

  
  Remark R4_3_3: const_pathS_eps n2 alpha (canon beta (S n1)).
  Proof.
    eapply const_pathS_eps_trans with beta; auto.
    - apply R4_3_1 .
    - apply R4_3_2.
  Qed. 

  Remark R4_3_4 : (canon beta (S n1) t1<= canon alpha (S n2))%t1.
  Proof.
    destruct (T1_eq_dec alpha beta).     
    - subst.
      clear H4 H0; induction H1.
      +  apply LE_refl.
         now apply nf_canon.
      +  apply LE_trans with  (canon beta (S m));  auto. 
         apply canonS_LE; auto.
    - assert (beta t1< alpha)%t1.
      { apply  const_pathS_eps_LE_2 in H4;auto. 
        destruct H4, H2.
        do 2 (split; auto).
        destruct H2; auto.
        now subst beta.
      }
      assert (const_pathS n2 alpha (canon beta (S n1))).
      {
        generalize  R4_3_3; inversion 1.  auto.
        subst.
        destruct (@LT_irrefl beta).
        apply LT_trans with (canon beta (S n1));  auto.
        apply canonS_LT   ;auto. 
        intro;subst; cbn in H00; now destruct H00.
      }
      inversion H2.
      subst; destruct H3 as [_ H3].
      rewrite H3;  apply LE_refl.
      apply nf_canon;auto.
      destruct H3 as [_ H3].
      subst y;   eapply const_pathS_LE; eauto. 
      eapply nf_canon;eauto.  
  Qed. 
  
  Lemma Lemma_4_3_0 :
    const_pathS_eps n2 (canon alpha (S n2)) (canon beta (S n1)).
  Proof. 
    destruct (LE_LT_eq_dec R4_3_4).
    - left.
      eapply Proposition_2_3a with (alpha := alpha); auto.   
      generalize  R4_3_3; inversion 1; auto. 
      rewrite <- H2 in l; destruct (@LT_irrefl alpha).
      apply LT_trans with (canon alpha (S n2)); auto. 
      apply canonS_LT;auto. 
      now left. 
    - rewrite e;  now right.
  Qed. 
  
  
End Lemma_4_3_Proof.

Lemma Lemma_4_3 :
  forall alpha beta : T1,
    nf alpha ->
    nf beta ->
    forall n0 n1 n2 : nat,
      (n0 <= n2)%nat ->
      (n1 <= n2)%nat ->
      const_pathS_eps n0 alpha beta -> 
      const_pathS_eps  n2 (canon alpha (S n2)) (canon beta (S n1)).
Proof.
  intros.  
  destruct (T1_eq_dec alpha zero).
  - subst; destruct H3.
   + destruct (const_pathS_zero H3).
   + subst; cbn; now right.
  -  eapply  Lemma_4_3_0 with n0;eauto.
Qed.


Lemma const_pathS_LT' (i : nat) (alpha beta : T1) (H:nf alpha):
  const_pathS i alpha beta -> alpha = zero \/ beta t1< alpha.
Proof.
  intro H0; destruct (T1_eq_dec alpha zero).
  - now left.
  - right; eapply const_pathS_LT; eauto.
Qed.

Lemma Lemma_4_4_1 : forall s n alpha beta (Ha : nf alpha)
                           (Hb : nf beta),
                      sorted_ge n s ->
                      const_pathS_eps n alpha beta ->
                      const_pathS_eps (simple_last n s)
                              (gnawS alpha s) (gnawS beta s).
Proof.
  induction s.
  - intros; now cbn.
  - intros;  cbn;  apply IHs.
   +     apply nf_canon;eauto.
   +   apply nf_canon;eauto.
   +  eapply    sorted_tail'; eauto. 
   +     destruct (T1_eq_dec alpha T1.zero). 
    *    subst;  assert (beta = T1.zero).
         { destruct H0.
           - now apply const_pathS_zero in H0.
           - now symmetry.
         }
    subst; now right.
    * eapply Lemma_4_3 with  (n0 :=a);auto. 
      apply Cor12_2 with n; auto. 
      inversion H0; auto with arith.
     all: eapply sorted_head; eauto.
Qed. 


Lemma KP_arrow_zero n beta : KP_arrow n zero beta -> beta = zero.
Proof.  
  intros H;  red in H; rewrite <- clos_trans_t1n_iff in H. 
  rewrite clos_trans_tn1_iff in H.
  induction H.
  - destruct H as [x [H H0]]; inversion H0. now destruct H1.
  -  subst; destruct H as [x [H1 H2]].  inversion H2. now destruct H1.
Qed.

(* todo : avoid automaticaly named hypotheses *)

Lemma KP_5_iii n alpha beta:  nf alpha ->  nf beta -> 
                              const_pathS n alpha beta <->
                              KP_arrow n alpha beta.
Proof.
  intros H H0; split.
  - induction 1.   (* should be more trivial *)
    +  left; red.
       exists n; split; auto with arith.
    +  right with y.
       * exists n;   split.
         auto with arith.
         destruct H1; split; auto. 
       * destruct H1 as [H02 H1].
         apply IHclos_trans_1n;auto; subst y; now apply nf_canon.
  - induction 1.
   +  destruct H1; destruct H1.
      apply Cor12_1 with x0;auto.
      * destruct H2; subst y; apply canonS_LT; auto.
      *  left; split.
        -- intro; subst.
           inversion H2. now destruct H3.
         -- now destruct H2.
    +   apply const_pathS_trans with y.
       *  destruct H1; apply Cor12_1 with x0;auto.
          -- destruct H1 as [H1 H4].
             destruct H1.
             ++ destruct H4;  subst y; apply canonS_LT; auto.
             ++ destruct H4; subst;  apply canonS_LT; auto.
          --  now destruct H1.
          -- destruct H1.
          destruct H3 as [H4 H5]; left; split; auto.
       * apply IHclos_trans_1n; auto.
         destruct H1 as [i [H2' [H2'' H2''']]].
         subst; apply nf_canon; auto.      
Qed.

Lemma Lemma_4_4_0 :
  forall n p alpha beta (Halpha : alpha <> T1.zero),
    nf alpha -> nf beta -> (n <= p)%nat ->
    const_pathS_eps n alpha beta ->
    const_pathS_eps p (canon alpha (S p)) (canon beta (S p)).
Proof.
  intros; inversion H2.
   - eapply Lemma_4_3_0 with n;auto.
   - right.  
Qed.


Lemma standard_path_shift i alpha j beta :
  standard_pathS i alpha j beta ->
  standard_path (S i) alpha (S j) beta.
Proof.
  induction 1.
  - left; auto.
  - right; auto.
Qed.

Lemma standard_path_unshift_0 i alpha j beta : 
   standard_path i alpha j beta -> forall k l,
      i = S k -> j = S l -> 
  standard_pathS  k alpha l beta.
Proof.
  induction 1.
   -  intros k l H3 H4; subst; left; auto.
      injection H4; congruence.
   -  intros; subst; right.
      apply IHstandard_pathR; auto.
Qed.

Lemma standard_path_unshift i alpha j beta : 
  standard_path (S i) alpha (S j) beta -> 
  standard_pathS  i alpha j beta.
Proof.
  intros; eapply standard_path_unshift_0; eauto.
Qed.


Lemma standard_pathRS_le_inv : forall j beta i alpha, 
    standard_pathRS j beta i alpha -> (i <= j)%nat.
Proof.
  induction 1.  
  - subst;auto with arith.
  - auto with arith.
Qed.

Lemma standard_pathR_le_inv : forall j beta i alpha, 
    standard_pathR j beta i alpha -> (i <= j)%nat.
Proof.
  induction 1.  
  - subst;auto with arith.
  - auto with arith.
Qed.


Lemma standard_pathRS_zero : forall j beta i alpha,
    standard_pathRS j beta i alpha -> alpha <> zero.
Proof.
induction 1.    
 - intro; now subst.
 - intro; subst; apply IHstandard_pathRS; auto.
Qed.


Lemma standard_pathR_zero : forall j beta i alpha,
   standard_pathR j beta i alpha -> alpha <> zero.
Proof.
  induction 1.    
  - intro; now subst.
  - intro; subst; apply IHstandard_pathR; auto.
Qed.

Lemma standard_pathS_path_toS :
  forall i alpha j beta, standard_pathS i alpha j beta -> 
                         (i <= j)%nat ->
                         path_toS beta (interval i j) alpha.
Proof.
  induction 1.
  - subst; rewrite interval_singleton. 
    left; split; auto.
  - intros; rewrite interval_unroll. 
    + eright; auto.
      * split; auto.
        intro;subst; cbn in H; apply standard_pathRS_zero in H;
          now destruct H.
       * apply IHstandard_pathRS;  eapply standard_pathRS_le_inv; eauto.
    + eapply standard_pathRS_le_inv;eauto.
Qed.

Lemma standard_path_path_to i alpha j beta :
  standard_path i alpha j beta -> i <> 0 ->
  (i <= j)%nat ->
  path_to beta (interval i j) alpha.
Proof.
  induction 1.
  - subst; rewrite interval_singleton. 
    left; auto; red; destruct i.
    + now destruct H0.
    + split; auto.
  - intros;  rewrite interval_unroll. 
    + destruct i.
     *  now destruct H0.
     *   eright; auto.
       --  esplit.
           ++ intro; subst; simpl in H.
              apply standard_pathR_zero in H.
              now destruct H. 
           ++  reflexivity.
       -- eapply IHstandard_pathR; eauto.
          eapply standard_pathR_le_inv;eauto.
   + eapply standard_pathR_le_inv;eauto.
Qed.

Lemma standard_gnaw_zero l i :  standard_gnaw i zero l = zero.
Proof. 
 revert i; induction l; simpl; trivial.
Qed.

Lemma standard_gnaw_iota_from i alpha l :
  i <> 0 ->
  standard_gnaw i alpha l = gnaw alpha (iota_from i l).
Proof.
  generalize i alpha; induction l.
  - reflexivity.
  -  intros i0 alpha0 H;simpl; destruct i0.
  +   now destruct H.
  +   simpl; rewrite IHl; auto.
Qed.


Lemma standard_gnaw_plus : forall  (t1 t2 i:nat)(alpha : T1) ,
    standard_gnaw i alpha (t1 + t2)%nat =
    standard_gnaw (t1 +i)%nat (standard_gnaw i alpha t1) t2.
Proof.
  induction t1; simpl.
  -   trivial. 
  -  intros t2 i alpha; rewrite IHt1.
     replace (t1 + S i)%nat with (S (t1 + i))%nat; auto.
Qed. 

Lemma standard_path_LE : forall  j beta i alpha, 
    standard_path i alpha j beta   ->
    (i <= j)%nat.
Proof.
   eapply standard_pathR_le_inv; eauto.
Qed.


Lemma standard_pathR_nf : forall i alpha j beta,
    standard_pathR  j beta i alpha  -> nf alpha -> nf beta.
Proof.
  induction 1.
  - destruct i. now destruct H2.
    +  subst beta; intros; now apply nf_canon.
  -  intros; apply IHstandard_pathR.
     destruct i.
     +  simpl;auto with T1. now apply nf_canon.
+  unfold canon; now apply nf_canon.
Qed.

(* Here *)

Lemma standard_path_zero : forall i j alpha beta,
    standard_path i alpha j beta  -> 
    alpha = zero ->
    beta = zero.
Proof.
  induction 1. 
  - intro; subst; now rewrite canon_zero.
  - intro; subst; rewrite canon_zero in IHstandard_pathR; auto.
Qed.


Lemma standard_path_lt2 : forall i alpha j beta,
    (0 < i)%nat -> zero t1< alpha ->
    standard_pathR  j beta i alpha ->
    beta t1<  alpha.
Proof.
  induction 3.
  -  destruct i.
     + inversion H.
     + subst beta;  apply canonS_LT.
       * inversion H0; tauto.
       * red ; intro; subst; inversion H0.
         destruct H3; inversion H3.
  -  destruct (T1_eq_dec  beta zero).
     + subst; auto. 
     + destruct (T1_eq_dec (canon alpha i) zero).
       * rewrite e in H1; assert (beta = zero).
         { eapply standard_path_zero ; eauto. }
         subst;auto.
       *  apply LT_trans with (canon alpha i) ; auto.
          apply IHstandard_pathR; auto with arith.
          apply not_zero_lt.
          { destruct i.
            - simpl; auto with T1. apply nf_canon; eauto with T1.
            - apply nf_canon,  (LT_nf_r H0); auto.
          }
          { destruct i; auto. }
          destruct i.
          {
            apply canon0_LT; eauto with T1.
            intro; subst; auto. 
          }
          { apply canonS_LT.
            - apply (LT_nf_r H0).
            -  intro;subst; destruct n0;auto.
          }
Qed.

Lemma standard_path_compose  j beta k gamma :
  standard_path (S j) beta   k gamma   ->
  forall i alpha,  standard_path i alpha j beta->
                   standard_path i alpha k gamma.
Proof.
  induction 2.
  - intros; subst;constructor 2; auto. 
  - constructor 2; auto.
Qed.


Lemma standard_gnaw_S_zero : forall i n alpha  ,
      standard_gnaw n alpha i = zero -> standard_gnaw n alpha (S i)=zero.
Proof.
  induction i.
  - simpl; intros; subst; apply canon_zero.
  - intros; replace (S (S i)) with (S i + 1)%nat; [| lia].
    rewrite  standard_gnaw_plus, H,  standard_gnaw_zero; auto.
Qed.

Lemma standard_gnaw_to_path : forall t alpha i,
    alpha <> zero -> i <> 0 ->
    standard_gnaw i alpha t <> zero ->
    standard_path i alpha  (t + i)%nat
                  (standard_gnaw i alpha (S t)).
Proof.
  induction t.
  - simpl.  intros.  left; auto. 
  -   intros ; right. 
      specialize (IHt (canon alpha i) (S i)); 
        destruct (T1_eq_dec (canon  alpha i) zero).
      +     simpl in H1;  rewrite e in H1;
            rewrite standard_gnaw_zero in H1; now destruct H1.
      +       specialize (IHt n); cbn ;
              replace (t + S i)%nat with (S (t+i))%nat in IHt.
           * apply IHt; auto.
           * cbn in H1;  auto.
Qed.


Lemma standard_gnaw_nf l : forall i alpha,
  nf alpha -> nf (standard_gnaw i alpha l).
Proof.
  induction l.
  - cbn; auto.
  - intros; cbn ; destruct (T1_eq_dec (canon alpha i) zero) as [e|ne].   
    + rewrite e, standard_gnaw_zero; auto with T1.
    + apply IHl;  destruct i.
      * cbn; auto with T1.
     apply nf_canon; eauto with T1.        
    * now apply nf_canon.
Qed.

Lemma standard_path_equiv_1 :
  forall i j alpha beta, standard_path i alpha j beta  -> 
                         beta = standard_gnaw i alpha (S j -  i)%nat.
Proof.
induction 1.
 - subst j; replace (S i - i)%nat  with 1.
    +  subst; reflexivity.
    + abstract lia.
 -   subst beta; assert (i < j)%nat.
        { eapply standard_path_LE; apply H. }
        assert (H1 : (S j - i = S ( j -  i))%nat) by   lia.
        rewrite H1; simpl (standard_gnaw i alpha (S (S i - S j)));
        replace (S j - S i)%nat  with (j - i)%nat; auto.
Qed.

Lemma standard_path_equiv_2 :
  forall l i alpha, i <> 0 ->
                    let beta := standard_gnaw i alpha (S l)
                    in beta <> zero -> 
                       standard_path i alpha  (l + i)%nat beta.
Proof.
 induction l as [| l IHl].
 -  cbn; left; auto.
      intro; subst alpha; now  destruct i, H0.
 -  right;  specialize (IHl (S i) (canon alpha i)); simpl standard_gnaw in *.
    replace ((S l) +i )%nat with (l + S i)%nat.
    + apply IHl; auto. 
+  abstract lia.
Qed.

Lemma path_to_S_iota_from :
  forall l i alpha beta,  
    path_toS beta (iota_from i (S l)) alpha ->
    standard_pathRS (l + i)%nat beta i alpha.
Proof.
  induction l as [| l IHl]. 
  - left. 
    + inversion H.
      * now destruct H1.
      * inversion H4.
    + intros; inversion H; auto.
      * now destruct H1.
      *  inversion H4;  auto.
    + reflexivity.
  -    right; replace (S l + i)%nat with (l + S i)%nat. 
       + apply IHl; inversion H;  subst.
         destruct H2; now subst.
       + abstract lia.
Qed.

Lemma path_to_S_standard_pathS :
  forall  i j alpha beta,  (i <= j)%nat ->
    path_toS beta (interval i j) alpha ->
    standard_pathS i alpha j beta.
Proof.
  intros i j alpha beta H H0; unfold interval in H0.
  replace (S j - i)%nat with (S (j - i)) in H0 by lia.
  apply path_to_S_iota_from in H0.
  replace (j - i + i)%nat with j in H0 by lia.
  assumption. 
 Qed.

Lemma path_toS_standardS_equiv i j alpha beta :
  (i <= j)%nat ->  path_toS beta (interval i j) alpha <->
    standard_pathS i alpha j beta.
 Proof.  
   split; intros H0.
   - now apply path_to_S_standard_pathS.
   - now apply standard_pathS_path_toS.
 Qed.
 
Lemma path_to_standard_equiv i j alpha beta :
  i <> 0 -> (i <= j)%nat ->  path_to beta (interval i j) alpha <->
    standard_path i alpha j beta.
 Proof.  
   intros H H0; destruct i, j.
  - now destruct H.
  - now destruct H.
  - inversion H0.
  - split; intro.
  +   apply standard_path_shift.   
      rewrite <- path_toS_standardS_equiv.
      * rewrite <- shift_interval in H1.
        now rewrite path_toS_path_to.
      * abstract lia.
  +   rewrite <- shift_interval, <- path_toS_path_to;
       apply standard_path_unshift in H1.
      rewrite path_toS_standardS_equiv; auto.
      abstract lia.
 Qed.
 
Lemma standard_pathS_app i alpha j beta k gamma :
  (i <= j)%nat -> (j <= k)%nat ->
  standard_pathS i alpha j beta -> standard_pathS (S j) beta k gamma ->
  standard_pathS i alpha k gamma.
Proof.
  intros; apply standard_pathS_path_toS in H1; auto.
  +  apply standard_pathS_path_toS in H2.
     *  generalize (path_toS_app H2 H1); intro H3;
          rewrite <- interval_app in H3; auto.
        unfold interval in H3; replace k with (( k - i) + i)%nat.
        apply  path_to_S_iota_from; auto.   
       --   replace (S (k - i))%nat with (S k - i)%nat; [auto | lia].
       --  abstract lia.
     * eapply standard_pathRS_le_inv;eauto.
Qed.

Lemma ocons_standard_pathS : forall alpha n beta , 
    nf (ocons alpha n beta) -> forall gamma i j,
    standard_pathS  i beta j gamma -> gamma  <> 0 -> 
    standard_pathS  i (ocons alpha n beta) j (ocons alpha n gamma).
Proof.
  unfold standard_pathS; induction 2.
  - left; auto.  
    + discriminate.
    + rewrite canon_tail.
      * now rewrite H1. 
      * assumption.
      * intro; subst; simpl in H3;  now destruct H3.
  -  right; rewrite  canon_tail; auto.
        +  apply IHstandard_pathRS; auto.
           eapply nf_LT_right; auto.
          * eapply H.
          * apply canonS_LT;  trivial.
            eauto with T1.
            intro; subst; simpl in H0; destruct H1.
            apply standard_pathRS_zero in H0; now destruct H0. 
        + intro;subst;  simpl in H0; apply standard_pathRS_zero in H0;auto.
Qed.

Lemma ocons_standard_path : forall alpha n beta , 
    nf (ocons alpha n beta) -> forall gamma i j,
    standard_path i beta j gamma -> gamma  <> 0 -> i <> 0 ->
    standard_path i (ocons alpha n beta) j (ocons alpha n gamma).
Proof.
  unfold standard_path; induction 2.
  - left; destruct i; auto.
    + discriminate.
    + now destruct H3.
    + clear H5;  rewrite canon_tail; auto.
      * now  f_equal.
  -  intros; destruct i.
     + now destruct H2.
     + right;  rewrite  canon_tail; auto.
        * apply IHstandard_pathR; auto.
          eapply nf_LT_right; auto.
          -- eapply H.
          --   apply canonS_LT; trivial.
              eauto with T1.
              intro; subst.
              simpl in H0; apply standard_pathR_zero in H0.
              subst; now destruct H1; auto.
        * intro;subst;  apply standard_pathR_zero in H0.
          subst;  destruct H1; auto.
          simpl in H0; now destruct H0.
Qed.

Lemma flatten : forall (i:nat)  alpha (j:nat)  beta, 
     standard_path i alpha  j beta   ->
    nf alpha -> zero t1<  alpha -> (0 < i)%nat  -> 
    const_path j alpha beta.
Proof.
  induction 1.
  - subst; simpl; intros;  destruct i. 
    + now destruct H2.
    +  now left.
  -  intros;  assert (0 < j)%nat.
       { generalize (standard_pathR_le_inv H).
         intro;  auto with arith.
         lia.
         }
       +  destruct (T1_eq_dec (canon alpha i) zero) as [e | ne].
          { rewrite e in H; assert (beta = zero).
            { generalize (standard_path_zero  H); auto. }
            subst beta; destruct i.
            - inversion  H2.
            - destruct (canonS_zero_inv _ _ e).   
              + subst; red; destruct j.
                * inversion H3.
                * left; apply standard_pathR_zero in H;  now destruct H.
              + destruct j.
                * inversion  H3.
                * left; split.
                  -- intro; subst;  discriminate H5.
                  -- subst; reflexivity. 
          }
          destruct j.
          *   inversion H3.
          * destruct i. 
          -- inversion H2.
          -- apply const_pathS_trans with (canon alpha (S i)).
             ++ apply Cor12_1 with i; auto. 
                ** apply canonS_LT;auto.
                intro; subst; auto with T1.
                ** apply standard_pathR_le_inv in H;  abstract lia.
                ** left; split.
                   intro; subst; auto with T1.
                   reflexivity.
             ++  apply IHstandard_pathR; auto.
                 ** apply nf_canon; auto.
                 ** apply not_zero_lt;auto.
                    apply nf_canon; auto.
Qed.

Lemma standard_gnaw_to_zero :
  forall alpha ,  nf alpha -> forall i,
      {p:nat | standard_gnaw i alpha p = zero}.
Proof.
  intro alpha; transfinite_induction alpha.
  clear alpha; intros alpha Halpha H  i.
  destruct (T1_eq_dec alpha zero) as [e | ne].
  -  subst alpha; induction i; cbn;  now exists 0. 
  - specialize  (Halpha (canon alpha i)).  
    assert (canon alpha i t1< alpha)%t1. {
      destruct i.
      - apply canon0_LT; auto with T1. 
      - apply canonS_LT; auto.
    }
    assert (H1 := nf_canon i H).
    specialize (Halpha H0 H1 (S i)).
    destruct Halpha as [x e]; exists (S x); simpl; auto.
Qed.


Lemma standard_path_to_zero:
  forall  alpha i, nf alpha -> alpha <> zero  ->
                   {j: nat | standard_path (S i) alpha j zero}.
Proof.
  intro alpha; transfinite_induction alpha;
    clear alpha; intros alpha Halpha i  H.
  destruct (T1_eq_dec alpha zero).
  - subst; exists (S i); replace zero with (canon zero (S i)) at 2.
   + left; trivial.
     * discriminate.
   + reflexivity.
  - intros _; destruct (T1_eq_dec (canon alpha (S i)) zero).
    + exists (S i); left; auto.
    + specialize (Halpha (canonS alpha i) (canonS_LT i H n) (S i)).
      destruct Halpha; auto.
      * apply nf_canon; auto.
      * exists x; right; auto.
Qed.


Lemma standard_gnaw_2_zero :
  forall  alpha i, nf alpha ->
                   {t: nat | standard_gnaw i alpha t = zero }.
Proof.
  intro alpha; transfinite_induction alpha. 
  clear alpha; intros alpha Halpha i  H.
  destruct (T1_eq_dec alpha zero).
  - subst; exists 0; trivial.
  - specialize  (Halpha (canon alpha i)).
    assert (LT (canon  alpha i) alpha). (* TODO : A lemma canon_LT *)
   { destruct i.
    apply canon0_LT; eauto with T1.
    apply canonS_LT; eauto with T1.
   }
   destruct  (Halpha H0 (S i)) as [x Hx].
   * apply nf_canon;auto.
   * now exists (S x).
Qed.

(** This section is dedicated to the proof of Lemma p 300 of KS
    We associate to any path  from alpha to beta with a constant index $n+1$ 
    a path from alpha to beta with a sequence of indices n+1, n+2, n+3, ... *)


Section Constant_to_standard_Proof.
  Variables (alpha beta: T1) (n : nat).
  Hypotheses (Halpha: nf alpha) (Hpos : zero t1<  beta)
             (p : const_pathS n alpha  beta).

  Remark Rem0 : beta  t1< alpha.
  Proof.
    apply const_pathS_LT with n; auto.
  Qed.

  Remark Rem1 : {k:nat  &
                   {gamma: T1 |
                    standard_path (S n) alpha  k gamma   /\
                    gamma t1<  alpha}}.
  Proof.
    destruct (standard_path_to_zero n Halpha).
   -  intro; subst; destruct (const_pathS_zero p).  
   -  exists x, zero; split;auto.
      apply LT_trans with beta;auto.
      eapply   const_pathS_LT; eauto.
  Defined.
  
  Remark Rem01 : zero  t1< alpha.
  Proof.
    apply LT_trans with beta;[trivial | apply Rem0].
  Qed.


  Remark Rem02 : alpha <> zero.
  Proof.
    intro H; generalize Rem01; subst; apply not_LT_zero.
  Qed.



  Remark Rem2 : {t: nat | standard_gnaw (S n) alpha t t1< beta}.
  Proof.       
    destruct (standard_gnaw_to_zero  Halpha (S n));  exists x; now rewrite e.
  Qed.

  Let t := proj1_sig Rem2.

  
  

  Remark Rem03 :  (standard_gnaw (S n) alpha t t1< beta)%t1.
  Proof.
    unfold t; pattern (proj1_sig Rem2); apply proj2_sig.
  Qed. 

  Let P (i:nat) := le_b beta (standard_gnaw (S n) alpha i).

  Remark Rem04 : P 0.
  Proof.
    unfold P;red; simpl.  
    unfold le_b, lt_b.
    eenough (T1.compare alpha beta = Datatypes.Gt) as -> by auto.
    apply compare_gt_iff.
    generalize (const_pathS_LT Halpha p).
    destruct 1; tauto.
  Qed. 


  Remark Rem05 : P t = false.
  Proof.
    unfold P, le_b, lt_b;
    enough (T1.compare (standard_gnaw (S n) alpha t) beta = Datatypes.Lt) as -> by reflexivity.
    apply compare_lt_iff.
    destruct Rem03; tauto.
  Qed.

  Remark Rem06 : (0 <  t)%nat.
  Proof.
    generalize Rem03; destruct t.
    -  simpl; intro; destruct (@LT_irrefl alpha).
       apply LT_trans with beta;auto.
       eapply const_pathS_LT; eauto.
    - auto with arith. 
  Qed.
  
  Let l_def :=  first_toggle P 0 t  Rem06 Rem04 Rem05.

  Let l := proj1_sig l_def.
  
  Let gamma := standard_gnaw (S n) alpha l.

  Remark Rem08 :
    (0 <= l)%nat /\
    (l < t)%nat /\
    (forall i : nat,
        (0 <= i)%nat ->
        (i <= l)%nat -> P i = true) /\ P (S l) = false.
  Proof.
    unfold l; pattern (proj1_sig l_def); apply proj2_sig.
  Qed.

  Remark Rem09 : (l < t)%nat.
  Proof.   destruct Rem08; tauto. Qed.

  Remark Rem10 : P l = true.
  Proof.
    destruct Rem08 as [H H0];decompose [and] H0.
    apply H3; auto with arith.
  Qed.
  
  Remark Rem11 : P (S l) = false.
  Proof.
    destruct Rem08 as [H H0]; now decompose [and] H0.  
  Qed.

  Remark R12 : const_pathS (l+n) alpha beta.
  Proof.
    apply Cor12_1 with n; auto with arith.
    apply const_pathS_LT with n;auto.
  Qed.

  Remark R13 : (0 < l)%nat -> gamma <> zero ->
               standard_path (S n) alpha ((l + n)) gamma. 
  Proof.                                    
    destruct l.
    - intro H; destruct (Lt.lt_irrefl _ H).
    - intros H Hg; replace ((S n0) + n)%nat with ( n0 + S n)%nat.
      + unfold gamma;  apply standard_gnaw_to_path.
        * apply Rem02.
        * discriminate.
        * unfold gamma in Hg;  intro H0;
            apply standard_gnaw_S_zero in H0; contradiction.
      + abstract lia.
  Qed.
  
  Remark R14 : l = 0 -> gamma = alpha.
  Proof.             
    intro H; subst; subst l; unfold gamma; now rewrite H.
  Qed.


  Remark R15 : gamma <> zero ->
               (0 < l)%nat -> const_path (n + l) alpha gamma.
  Proof.
    intros Hg H;
      specialize (@flatten (S n) alpha (n + l) (standard_gnaw (S n) alpha l));
      intro H0;  apply H0; auto with arith.
    -   generalize (R13 H);intro;
          simpl in H1; replace (n+l)%nat with (l+n)%nat; auto with arith.
    -    apply not_zero_lt; auto.
         apply Rem02.
  Qed.
  
  Let m := Nat.pred (n + l).

  Lemma m_def : (0 < l)%nat -> (n + l = S m)%nat.
  Proof.
    unfold m; abstract lia.
  Qed.

  Remark R16 : (0 < l)%nat  -> const_path (n + l) alpha beta.
  Proof.
    intro H; rewrite m_def;auto.
    -  apply Cor12_1 with n;auto.
       +  apply const_pathS_LT with n; auto.
       +  unfold m; abstract lia.
  Qed.

   Remark R17 : (0 < l)%nat -> const_pathS (n+l) alpha beta.
  Proof.
    intro H;  generalize (R16 H); intro H0.
    case_eq  (n + l)%nat.
    -   intro H1;  elimtype False. 
        abstract lia.
    -  intros n0 H1; rewrite H1 in *; apply Cor12_1 with n0;auto.
       apply Rem0.
  Qed. 

  Remark R18 : gamma <> zero -> (0 < l)%nat -> const_pathS (n+l) alpha gamma.
  Proof.
    intros Hg H; generalize (R15 Hg H); case_eq  (n + l)%nat.
    -  intro;  elimtype False; abstract lia.
    -  intros n0 H1 H2;  apply Cor12_1 with n0;auto.
       apply const_pathS_LT with n0;auto;  apply Rem02.
  Qed.


  Remark R19 : beta t1<= gamma.
  Proof.
    generalize Rem10;unfold P; fold gamma ;unfold le_b, lt_b.
    intro H.
    destruct (T1.compare gamma beta) eqn: Hcomp.
    - apply compare_eq_iff in Hcomp as ->.
      apply LE_refl.
      eapply LT_nf_r; eauto.
    - intros; discriminate.
    - apply LE_r.
      rewrite compare_gt_iff in Hcomp; repeat split; auto.
      + eapply LT_nf_r; eauto.
      + subst gamma; eapply standard_gnaw_nf; eauto.
  Qed.


  Remark R20 : gamma <> zero -> (0 < l)%nat -> beta t1< gamma ->
               const_pathS (n+l) gamma beta.
  Proof.
    intros; apply Proposition_2_3a with alpha; auto.
    - apply Rem02.
    - apply R17; auto.
    - apply R18;auto.
  Qed.

  Remark R21 : gamma <> zero -> (0 < l)%nat ->
               gamma = beta \/ const_pathS (n+l) gamma beta.
  Proof. 
    intros Hg H; destruct (LE_LT_eq_dec R19).
    - right;  apply R20;auto.  
    - left;auto. 
  Qed.

  Let delta := canon gamma (S (n + l))%nat.

  Remark R22 : delta = standard_gnaw (S n) alpha (S l).

  Proof.
    replace (S l) with (l + 1)%nat;[| lia].
    rewrite standard_gnaw_plus.  fold gamma.  
    simpl;  replace (l + S n)%nat with (S (n+l)); [trivial | lia].
  Qed.


  Remark R23 : const_pathS (n+l) gamma beta ->
               {beta = delta}+{const_pathS (n + l) delta beta}.
  Proof.
    intro H; now apply const_pathS_inv_strong.
  Qed.

  Remark R24 : const_pathS (n+l) gamma beta -> beta t1<= delta.
  Proof.
    intro H; destruct (R23 H).
    - rewrite <- e; apply LE_refl.
      eapply LT_nf_r; eauto.
    - apply LE_r;auto.
      eapply const_pathS_LT;eauto.
      +  unfold delta; apply nf_canon.
        unfold gamma; apply standard_gnaw_nf;auto. 
  Qed.

   Remark R25 : delta t1< beta.
  Proof.
    rewrite R22; generalize Rem11;unfold P; intro H;
      unfold le_b, lt_b in H.
    destruct( T1.compare (standard_gnaw (S n) alpha (S l)) beta) eqn: H0.
    - discriminate.
    - rewrite compare_lt_iff in H0.
       repeat split;auto.
       +  apply standard_gnaw_nf;auto.
       +  eapply LT_nf_r; eauto.
    - discriminate.
  Qed.

   Remark R26 : ~ const_pathS (n+l) gamma beta.
  Proof.
    intro H; destruct (@LT_irrefl delta).
    apply LT_LE_trans with beta;auto.
    -  apply R25;auto.
    -  apply R24;auto.
  Qed.

   Remark R27 : gamma <> zero -> (0 < l)%nat -> gamma = beta.
  Proof.
    intros Hg H; destruct (R21 Hg H); auto. 
    destruct (R26 H0).
  Qed.

   Remark R28 : l = 0 -> (beta t1<= delta)%t1.
  Proof.
    intro H; apply R24; replace (n+l)%nat with n.
    -  rewrite R14; auto.
    -  rewrite H; auto with arith. 
  Qed.

  Remark R29 : l <> 0.
  Proof.
    intro H; destruct (@LT_irrefl delta).
    - apply LT_LE_trans with beta;auto.
      + apply R25;auto.
      + apply R28;auto.
  Qed.
  
  Remark R30 : gamma <> zero -> gamma = beta.
  Proof.
    case_eq l.
    - intro; elimtype False.
      apply R29;auto.
    - intros n0 H H0; apply R27;auto.
      rewrite H;auto with arith. 
  Qed.
  
  Remark R31_0 : gamma <> zero -> beta = standard_gnaw (S n) alpha l.
  Proof.  intro; rewrite <- R30; auto. Qed.
  
  
  Lemma gamma_positive : gamma <> zero.
  Proof.
    generalize R19; intro.
    generalize Hpos;intro.
    intro H0; rewrite H0 in H.
    assert (zero  t1< zero).
    apply LT_LE_trans with beta;auto.
    eapply LT_irrefl; eauto.
  Qed.
  
  Remark R31 : beta = standard_gnaw (S n) alpha l.
  Proof.
    apply R31_0, gamma_positive.
  Qed.
  
  Lemma constant_to_standard_0 :
    {l : nat | standard_gnaw (S n) alpha l = beta}.
  Proof. exists l; now rewrite R31.  Qed. 
  
End Constant_to_standard_Proof.


Lemma  constant_to_standard  (alpha beta : T1) (n : nat):
    nf alpha -> const_pathS n alpha beta ->
    {l : nat | standard_gnaw (S n) alpha l = beta}.
Proof.
  intros  H H0; destruct (T1_eq_dec beta zero).
  - subst beta;  destruct (standard_gnaw_to_zero H (S n)).
    now exists x.
               - apply constant_to_standard_0;auto.
                 apply not_zero_lt; auto.
                 now apply const_pathS_nf with n alpha.
Qed.

Lemma constant_to_standard_path 
  (alpha beta : T1) (i : nat):
  nf alpha -> const_pathS i alpha beta -> zero  t1< alpha ->
  {j:nat | standard_path (S i) alpha j beta}.
Proof.
   intros H H0 H1;  destruct (T1_eq_dec beta zero).
   - subst; apply standard_path_to_zero; auto.
     intro; subst; eapply LT_irrefl; eauto.
   - destruct (constant_to_standard H  H0) as [x e].
     destruct x as [| x].
     +  simpl in e; subst.
        destruct (@LT_irrefl beta).
        apply const_pathS_LT with i.
       *  auto. 
     * auto.
   +  exists ( x + S i)%nat; subst beta;
       apply standard_gnaw_to_path.
    *  intro; subst; eapply LT_irrefl;eauto.
    * discriminate.
    * intro H2; apply standard_gnaw_S_zero in H2; contradiction.
Qed.


Corollary  LT_to_standard_path 
      (alpha beta : T1) :
  beta  t1< alpha ->
  {n : nat & {j:nat | standard_path (S n) alpha j beta}}.
Proof.
  intros H; assert (nf alpha) by eauto with T1.
  destruct (Lemma2_6_1 H0 H) as [n Hn].
  exists n;  apply constant_to_standard_path; auto.
  apply LE_LT_trans with beta; eauto with T1.
  apply LE_zero; eauto with T1.
Qed.

Lemma const_path_const_pathS_equiv : forall alpha i beta ,
    const_path (S i) alpha beta <->
    const_pathS i alpha beta.
Proof.
  intros; split; intro; assumption.
Qed.


(** * Adaptation to [E0] *)



Definition Canon_plus (i:nat)( alpha beta:E0)
  := const_path i (cnf alpha) (cnf beta).


Lemma Canon_plus_inv n alpha beta :
  Canon_plus  (S n) alpha beta ->
  beta = Canon alpha (S n) \/
  Canon_plus (S n) (Canon alpha (S n)) beta.
Proof.
  unfold Canon_plus, Canon; repeat rewrite const_path_const_pathS_equiv. 
  intro H; destruct (const_pathS_inv H).
  -  left; apply E0_eq_intro, H0.  
  - right; apply H0.
Qed.


Theorem KS_thm_2_4_E0 :
  forall lambda, 
    Limitb lambda  ->
    forall i j, (i < j)%nat ->
                Canon_plus 1 (Canon lambda (S j))
                       (Canon lambda (S i)).
Proof.
  intros; destruct lambda; cbn;  apply KS_thm_2_4;auto.
Qed.

Corollary Cor12_E0 : forall alpha beta i n, 
    Lt beta alpha -> (i <= n)%nat ->
    Canon_plus (S i) alpha beta ->
    Canon_plus (S n) alpha beta.
Proof.
  intros.
  destruct (Lt.le_lt_or_eq _ _ H0).
  eapply Cor12;eauto.
  destruct alpha; auto.
  now subst.
Qed.

(** To move to T1 !!! *)
Lemma not_zero_gt_0 (alpha:T1) : alpha <> zero -> lt zero  alpha.
destruct alpha.
  - now destruct 1.
  - auto with T1.
Qed.

Lemma Canon_mono1 alpha i j : Limitb alpha -> (i< j)% nat ->
                              (Canon alpha i o< Canon alpha j)%e0.

  destruct alpha.
  unfold Canon.
  destruct i, j.
  - inversion 2.
  - unfold lt. simpl.
    intros. clear H0.
    split; auto.
    cbn. auto with T1.

    split; cbn. 
    Search  zero canon limitb.
    specialize (limitb_canonS_not_zero j cnf_ok H).
    intro. 
    now apply not_zero_gt_0.
    apply nf_canon. 
auto. 

  - intros; lia.
  -        
   unfold lt; simpl.
    simpl; intros.
    apply canonS_limit_mono; auto.
    auto with arith.
Qed.


Lemma CanonS_plus_1 alpha beta k i :
  beta  <> Zero -> alpha <> Zero  ->
  (beta o< Phi0 alpha)%e0 ->
  (CanonS (Omega_term alpha i + beta)%e0 k =
   (Omega_term alpha  i + (CanonS beta k))%e0).
Proof.
  intros;  apply E0_eq_intro.
  rewrite  Omega_term_plus; auto.
  -  destruct alpha as [alpha Halpha];
       destruct beta as [beta Hbeta].
     red in H0;unfold E0.cnf; simpl in *.
     destruct beta.
     + destruct H; now apply E0_eq_intro.
     + destruct (T1.compare alpha beta1) eqn:H2.
         * unfold lt in H1; simpl in H1.
           rewrite compare_eq_iff in H2;  subst beta1.
           destruct (LT_inv H1).
           -- destruct (LT_irrefl H2).      
           -- destruct H2.
               destruct H3.
               ++ inversion H3.
               ++ destruct H3 as [_ H4]; destruct (not_LT_zero H4).
         * red in H1; simpl in H1; destruct (LT_inv H1).
           -- destruct H3 as [_ [H4 _]].
              now apply compare_lt_iff, lt_not_gt in H2.
           -- destruct H3. subst.
              destruct H4.
             ++ inversion H3.
             ++ destruct H3 as [_ H4]; destruct (not_LT_zero H4).
         * unfold canonS; rewrite canon_tail; auto.
           -- apply ocons_nf; auto with T1.
              rewrite compare_gt_iff in H2; auto.
           --  discriminate.
  - apply Lt_trans with beta; auto.
    apply CanonS_lt; auto.
Qed.

Lemma CanonS_Phi0_Succ_eqn i gamma:
  CanonS (Phi0 (Succ gamma)) i = Omega_term gamma i.
Proof.
  apply E0_eq_intro;  unfold CanonS, canonS.
  rewrite cnf_rw, cnf_Omega_term, cnf_Phi0, cnf_Succ.
  rewrite canonS_phi0_succ_eqn; auto with E0.
Qed.  


Lemma Lemma2_6_1_E0 (alpha beta: E0) :
    (beta o< alpha)%e0  ->
    {n:nat | Canon_plus (S n) alpha beta}.
Proof.
  destruct alpha, beta; unfold Lt; simpl. simpl.
 intro H; eapply Lemma2_6_1; eauto.
Defined.


(** Lemmas used by [F_alpha] *)

Lemma Canon_plus_first_step: forall i alpha beta, 
    Canon_plus (S i) (Succ alpha) beta ->
    alpha = beta \/ Canon_plus (S i) alpha beta.
Proof.
  destruct alpha, beta.
  unfold Canon_plus, const_path; simpl ;intros H.
  destruct (const_pathS_first_step H).
  - rewrite canon_succ in e; auto.
    subst cnf0;  assert (cnf_ok0 =cnf_ok).
    apply nf_proof_unicity.
    subst cnf_ok0; left;auto. 
  - rewrite canon_succ in c;[ right;auto | auto].
Qed.

Lemma Canon_plus_first_step_lim:
  forall i alpha beta, Limitb alpha ->
                       Canon_plus (S i) alpha beta  ->
                       beta = CanonS alpha i \/
                       Canon_plus (S i) (CanonS alpha i) beta.
Proof.
  destruct alpha, beta.
  unfold Canon_plus, const_path; simpl.
  intros H H0; destruct (const_pathS_first_step H0).
  -  left;  unfold CanonS;   f_equal;  f_equal. simpl; subst cnf0.
     f_equal; apply nf_proof_unicity.
  - right; auto.
Qed.


